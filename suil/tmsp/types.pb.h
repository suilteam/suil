// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: types.proto

#ifndef PROTOBUF_INCLUDED_types_2eproto
#define PROTOBUF_INCLUDED_types_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_types_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_types_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[44]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
namespace suil {
namespace tmsp {
namespace types {
class BlockID;
class BlockIDDefaultTypeInternal;
extern BlockIDDefaultTypeInternal _BlockID_default_instance_;
class BlockSizeParams;
class BlockSizeParamsDefaultTypeInternal;
extern BlockSizeParamsDefaultTypeInternal _BlockSizeParams_default_instance_;
class ConsensusParams;
class ConsensusParamsDefaultTypeInternal;
extern ConsensusParamsDefaultTypeInternal _ConsensusParams_default_instance_;
class Evidence;
class EvidenceDefaultTypeInternal;
extern EvidenceDefaultTypeInternal _Evidence_default_instance_;
class EvidenceParams;
class EvidenceParamsDefaultTypeInternal;
extern EvidenceParamsDefaultTypeInternal _EvidenceParams_default_instance_;
class Header;
class HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class KI64Pair;
class KI64PairDefaultTypeInternal;
extern KI64PairDefaultTypeInternal _KI64Pair_default_instance_;
class KVPair;
class KVPairDefaultTypeInternal;
extern KVPairDefaultTypeInternal _KVPair_default_instance_;
class LastCommitInfo;
class LastCommitInfoDefaultTypeInternal;
extern LastCommitInfoDefaultTypeInternal _LastCommitInfo_default_instance_;
class PartSetHeader;
class PartSetHeaderDefaultTypeInternal;
extern PartSetHeaderDefaultTypeInternal _PartSetHeader_default_instance_;
class Proof;
class ProofDefaultTypeInternal;
extern ProofDefaultTypeInternal _Proof_default_instance_;
class ProofOp;
class ProofOpDefaultTypeInternal;
extern ProofOpDefaultTypeInternal _ProofOp_default_instance_;
class PubKey;
class PubKeyDefaultTypeInternal;
extern PubKeyDefaultTypeInternal _PubKey_default_instance_;
class Request;
class RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class RequestBeginBlock;
class RequestBeginBlockDefaultTypeInternal;
extern RequestBeginBlockDefaultTypeInternal _RequestBeginBlock_default_instance_;
class RequestCheckTx;
class RequestCheckTxDefaultTypeInternal;
extern RequestCheckTxDefaultTypeInternal _RequestCheckTx_default_instance_;
class RequestCommit;
class RequestCommitDefaultTypeInternal;
extern RequestCommitDefaultTypeInternal _RequestCommit_default_instance_;
class RequestDeliverTx;
class RequestDeliverTxDefaultTypeInternal;
extern RequestDeliverTxDefaultTypeInternal _RequestDeliverTx_default_instance_;
class RequestEcho;
class RequestEchoDefaultTypeInternal;
extern RequestEchoDefaultTypeInternal _RequestEcho_default_instance_;
class RequestEndBlock;
class RequestEndBlockDefaultTypeInternal;
extern RequestEndBlockDefaultTypeInternal _RequestEndBlock_default_instance_;
class RequestFlush;
class RequestFlushDefaultTypeInternal;
extern RequestFlushDefaultTypeInternal _RequestFlush_default_instance_;
class RequestInfo;
class RequestInfoDefaultTypeInternal;
extern RequestInfoDefaultTypeInternal _RequestInfo_default_instance_;
class RequestInitChain;
class RequestInitChainDefaultTypeInternal;
extern RequestInitChainDefaultTypeInternal _RequestInitChain_default_instance_;
class RequestQuery;
class RequestQueryDefaultTypeInternal;
extern RequestQueryDefaultTypeInternal _RequestQuery_default_instance_;
class RequestSetOption;
class RequestSetOptionDefaultTypeInternal;
extern RequestSetOptionDefaultTypeInternal _RequestSetOption_default_instance_;
class Response;
class ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
class ResponseBeginBlock;
class ResponseBeginBlockDefaultTypeInternal;
extern ResponseBeginBlockDefaultTypeInternal _ResponseBeginBlock_default_instance_;
class ResponseCheckTx;
class ResponseCheckTxDefaultTypeInternal;
extern ResponseCheckTxDefaultTypeInternal _ResponseCheckTx_default_instance_;
class ResponseCommit;
class ResponseCommitDefaultTypeInternal;
extern ResponseCommitDefaultTypeInternal _ResponseCommit_default_instance_;
class ResponseDeliverTx;
class ResponseDeliverTxDefaultTypeInternal;
extern ResponseDeliverTxDefaultTypeInternal _ResponseDeliverTx_default_instance_;
class ResponseEcho;
class ResponseEchoDefaultTypeInternal;
extern ResponseEchoDefaultTypeInternal _ResponseEcho_default_instance_;
class ResponseEndBlock;
class ResponseEndBlockDefaultTypeInternal;
extern ResponseEndBlockDefaultTypeInternal _ResponseEndBlock_default_instance_;
class ResponseException;
class ResponseExceptionDefaultTypeInternal;
extern ResponseExceptionDefaultTypeInternal _ResponseException_default_instance_;
class ResponseFlush;
class ResponseFlushDefaultTypeInternal;
extern ResponseFlushDefaultTypeInternal _ResponseFlush_default_instance_;
class ResponseInfo;
class ResponseInfoDefaultTypeInternal;
extern ResponseInfoDefaultTypeInternal _ResponseInfo_default_instance_;
class ResponseInitChain;
class ResponseInitChainDefaultTypeInternal;
extern ResponseInitChainDefaultTypeInternal _ResponseInitChain_default_instance_;
class ResponseQuery;
class ResponseQueryDefaultTypeInternal;
extern ResponseQueryDefaultTypeInternal _ResponseQuery_default_instance_;
class ResponseSetOption;
class ResponseSetOptionDefaultTypeInternal;
extern ResponseSetOptionDefaultTypeInternal _ResponseSetOption_default_instance_;
class Timestamp;
class TimestampDefaultTypeInternal;
extern TimestampDefaultTypeInternal _Timestamp_default_instance_;
class Validator;
class ValidatorDefaultTypeInternal;
extern ValidatorDefaultTypeInternal _Validator_default_instance_;
class ValidatorParams;
class ValidatorParamsDefaultTypeInternal;
extern ValidatorParamsDefaultTypeInternal _ValidatorParams_default_instance_;
class ValidatorUpdate;
class ValidatorUpdateDefaultTypeInternal;
extern ValidatorUpdateDefaultTypeInternal _ValidatorUpdate_default_instance_;
class Version;
class VersionDefaultTypeInternal;
extern VersionDefaultTypeInternal _Version_default_instance_;
class VoteInfo;
class VoteInfoDefaultTypeInternal;
extern VoteInfoDefaultTypeInternal _VoteInfo_default_instance_;
}  // namespace types
}  // namespace tmsp
}  // namespace suil
namespace google {
namespace protobuf {
template<> ::suil::tmsp::types::BlockID* Arena::CreateMaybeMessage<::suil::tmsp::types::BlockID>(Arena*);
template<> ::suil::tmsp::types::BlockSizeParams* Arena::CreateMaybeMessage<::suil::tmsp::types::BlockSizeParams>(Arena*);
template<> ::suil::tmsp::types::ConsensusParams* Arena::CreateMaybeMessage<::suil::tmsp::types::ConsensusParams>(Arena*);
template<> ::suil::tmsp::types::Evidence* Arena::CreateMaybeMessage<::suil::tmsp::types::Evidence>(Arena*);
template<> ::suil::tmsp::types::EvidenceParams* Arena::CreateMaybeMessage<::suil::tmsp::types::EvidenceParams>(Arena*);
template<> ::suil::tmsp::types::Header* Arena::CreateMaybeMessage<::suil::tmsp::types::Header>(Arena*);
template<> ::suil::tmsp::types::KI64Pair* Arena::CreateMaybeMessage<::suil::tmsp::types::KI64Pair>(Arena*);
template<> ::suil::tmsp::types::KVPair* Arena::CreateMaybeMessage<::suil::tmsp::types::KVPair>(Arena*);
template<> ::suil::tmsp::types::LastCommitInfo* Arena::CreateMaybeMessage<::suil::tmsp::types::LastCommitInfo>(Arena*);
template<> ::suil::tmsp::types::PartSetHeader* Arena::CreateMaybeMessage<::suil::tmsp::types::PartSetHeader>(Arena*);
template<> ::suil::tmsp::types::Proof* Arena::CreateMaybeMessage<::suil::tmsp::types::Proof>(Arena*);
template<> ::suil::tmsp::types::ProofOp* Arena::CreateMaybeMessage<::suil::tmsp::types::ProofOp>(Arena*);
template<> ::suil::tmsp::types::PubKey* Arena::CreateMaybeMessage<::suil::tmsp::types::PubKey>(Arena*);
template<> ::suil::tmsp::types::Request* Arena::CreateMaybeMessage<::suil::tmsp::types::Request>(Arena*);
template<> ::suil::tmsp::types::RequestBeginBlock* Arena::CreateMaybeMessage<::suil::tmsp::types::RequestBeginBlock>(Arena*);
template<> ::suil::tmsp::types::RequestCheckTx* Arena::CreateMaybeMessage<::suil::tmsp::types::RequestCheckTx>(Arena*);
template<> ::suil::tmsp::types::RequestCommit* Arena::CreateMaybeMessage<::suil::tmsp::types::RequestCommit>(Arena*);
template<> ::suil::tmsp::types::RequestDeliverTx* Arena::CreateMaybeMessage<::suil::tmsp::types::RequestDeliverTx>(Arena*);
template<> ::suil::tmsp::types::RequestEcho* Arena::CreateMaybeMessage<::suil::tmsp::types::RequestEcho>(Arena*);
template<> ::suil::tmsp::types::RequestEndBlock* Arena::CreateMaybeMessage<::suil::tmsp::types::RequestEndBlock>(Arena*);
template<> ::suil::tmsp::types::RequestFlush* Arena::CreateMaybeMessage<::suil::tmsp::types::RequestFlush>(Arena*);
template<> ::suil::tmsp::types::RequestInfo* Arena::CreateMaybeMessage<::suil::tmsp::types::RequestInfo>(Arena*);
template<> ::suil::tmsp::types::RequestInitChain* Arena::CreateMaybeMessage<::suil::tmsp::types::RequestInitChain>(Arena*);
template<> ::suil::tmsp::types::RequestQuery* Arena::CreateMaybeMessage<::suil::tmsp::types::RequestQuery>(Arena*);
template<> ::suil::tmsp::types::RequestSetOption* Arena::CreateMaybeMessage<::suil::tmsp::types::RequestSetOption>(Arena*);
template<> ::suil::tmsp::types::Response* Arena::CreateMaybeMessage<::suil::tmsp::types::Response>(Arena*);
template<> ::suil::tmsp::types::ResponseBeginBlock* Arena::CreateMaybeMessage<::suil::tmsp::types::ResponseBeginBlock>(Arena*);
template<> ::suil::tmsp::types::ResponseCheckTx* Arena::CreateMaybeMessage<::suil::tmsp::types::ResponseCheckTx>(Arena*);
template<> ::suil::tmsp::types::ResponseCommit* Arena::CreateMaybeMessage<::suil::tmsp::types::ResponseCommit>(Arena*);
template<> ::suil::tmsp::types::ResponseDeliverTx* Arena::CreateMaybeMessage<::suil::tmsp::types::ResponseDeliverTx>(Arena*);
template<> ::suil::tmsp::types::ResponseEcho* Arena::CreateMaybeMessage<::suil::tmsp::types::ResponseEcho>(Arena*);
template<> ::suil::tmsp::types::ResponseEndBlock* Arena::CreateMaybeMessage<::suil::tmsp::types::ResponseEndBlock>(Arena*);
template<> ::suil::tmsp::types::ResponseException* Arena::CreateMaybeMessage<::suil::tmsp::types::ResponseException>(Arena*);
template<> ::suil::tmsp::types::ResponseFlush* Arena::CreateMaybeMessage<::suil::tmsp::types::ResponseFlush>(Arena*);
template<> ::suil::tmsp::types::ResponseInfo* Arena::CreateMaybeMessage<::suil::tmsp::types::ResponseInfo>(Arena*);
template<> ::suil::tmsp::types::ResponseInitChain* Arena::CreateMaybeMessage<::suil::tmsp::types::ResponseInitChain>(Arena*);
template<> ::suil::tmsp::types::ResponseQuery* Arena::CreateMaybeMessage<::suil::tmsp::types::ResponseQuery>(Arena*);
template<> ::suil::tmsp::types::ResponseSetOption* Arena::CreateMaybeMessage<::suil::tmsp::types::ResponseSetOption>(Arena*);
template<> ::suil::tmsp::types::Timestamp* Arena::CreateMaybeMessage<::suil::tmsp::types::Timestamp>(Arena*);
template<> ::suil::tmsp::types::Validator* Arena::CreateMaybeMessage<::suil::tmsp::types::Validator>(Arena*);
template<> ::suil::tmsp::types::ValidatorParams* Arena::CreateMaybeMessage<::suil::tmsp::types::ValidatorParams>(Arena*);
template<> ::suil::tmsp::types::ValidatorUpdate* Arena::CreateMaybeMessage<::suil::tmsp::types::ValidatorUpdate>(Arena*);
template<> ::suil::tmsp::types::Version* Arena::CreateMaybeMessage<::suil::tmsp::types::Version>(Arena*);
template<> ::suil::tmsp::types::VoteInfo* Arena::CreateMaybeMessage<::suil::tmsp::types::VoteInfo>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace suil {
namespace tmsp {
namespace types {

// ===================================================================

class ProofOp final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:suil.tmsp.types.ProofOp) */ {
 public:
  ProofOp();
  virtual ~ProofOp();

  ProofOp(const ProofOp& from);

  inline ProofOp& operator=(const ProofOp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProofOp(ProofOp&& from) noexcept
    : ProofOp() {
    *this = ::std::move(from);
  }

  inline ProofOp& operator=(ProofOp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ProofOp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProofOp* internal_default_instance() {
    return reinterpret_cast<const ProofOp*>(
               &_ProofOp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ProofOp* other);
  friend void swap(ProofOp& a, ProofOp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProofOp* New() const final {
    return CreateMaybeMessage<ProofOp>(nullptr);
  }

  ProofOp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProofOp>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ProofOp& from);
  void MergeFrom(const ProofOp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ProofOp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // bytes key = 2;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // bytes data = 3;
  void clear_data();
  static const int kDataFieldNumber = 3;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:suil.tmsp.types.ProofOp)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class Proof final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:suil.tmsp.types.Proof) */ {
 public:
  Proof();
  virtual ~Proof();

  Proof(const Proof& from);

  inline Proof& operator=(const Proof& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Proof(Proof&& from) noexcept
    : Proof() {
    *this = ::std::move(from);
  }

  inline Proof& operator=(Proof&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Proof& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Proof* internal_default_instance() {
    return reinterpret_cast<const Proof*>(
               &_Proof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Proof* other);
  friend void swap(Proof& a, Proof& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Proof* New() const final {
    return CreateMaybeMessage<Proof>(nullptr);
  }

  Proof* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Proof>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Proof& from);
  void MergeFrom(const Proof& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Proof* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .suil.tmsp.types.ProofOp ops = 1;
  int ops_size() const;
  void clear_ops();
  static const int kOpsFieldNumber = 1;
  ::suil::tmsp::types::ProofOp* mutable_ops(int index);
  ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::ProofOp >*
      mutable_ops();
  const ::suil::tmsp::types::ProofOp& ops(int index) const;
  ::suil::tmsp::types::ProofOp* add_ops();
  const ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::ProofOp >&
      ops() const;

  // @@protoc_insertion_point(class_scope:suil.tmsp.types.Proof)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::ProofOp > ops_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class KVPair final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:suil.tmsp.types.KVPair) */ {
 public:
  KVPair();
  virtual ~KVPair();

  KVPair(const KVPair& from);

  inline KVPair& operator=(const KVPair& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KVPair(KVPair&& from) noexcept
    : KVPair() {
    *this = ::std::move(from);
  }

  inline KVPair& operator=(KVPair&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const KVPair& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KVPair* internal_default_instance() {
    return reinterpret_cast<const KVPair*>(
               &_KVPair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(KVPair* other);
  friend void swap(KVPair& a, KVPair& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KVPair* New() const final {
    return CreateMaybeMessage<KVPair>(nullptr);
  }

  KVPair* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KVPair>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const KVPair& from);
  void MergeFrom(const KVPair& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KVPair* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // bytes value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:suil.tmsp.types.KVPair)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class KI64Pair final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:suil.tmsp.types.KI64Pair) */ {
 public:
  KI64Pair();
  virtual ~KI64Pair();

  KI64Pair(const KI64Pair& from);

  inline KI64Pair& operator=(const KI64Pair& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KI64Pair(KI64Pair&& from) noexcept
    : KI64Pair() {
    *this = ::std::move(from);
  }

  inline KI64Pair& operator=(KI64Pair&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const KI64Pair& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KI64Pair* internal_default_instance() {
    return reinterpret_cast<const KI64Pair*>(
               &_KI64Pair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(KI64Pair* other);
  friend void swap(KI64Pair& a, KI64Pair& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KI64Pair* New() const final {
    return CreateMaybeMessage<KI64Pair>(nullptr);
  }

  KI64Pair* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KI64Pair>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const KI64Pair& from);
  void MergeFrom(const KI64Pair& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KI64Pair* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // int64 value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  ::google::protobuf::int64 value() const;
  void set_value(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:suil.tmsp.types.KI64Pair)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::int64 value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class Timestamp final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:suil.tmsp.types.Timestamp) */ {
 public:
  Timestamp();
  virtual ~Timestamp();

  Timestamp(const Timestamp& from);

  inline Timestamp& operator=(const Timestamp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Timestamp(Timestamp&& from) noexcept
    : Timestamp() {
    *this = ::std::move(from);
  }

  inline Timestamp& operator=(Timestamp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Timestamp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Timestamp* internal_default_instance() {
    return reinterpret_cast<const Timestamp*>(
               &_Timestamp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Timestamp* other);
  friend void swap(Timestamp& a, Timestamp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Timestamp* New() const final {
    return CreateMaybeMessage<Timestamp>(nullptr);
  }

  Timestamp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Timestamp>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Timestamp& from);
  void MergeFrom(const Timestamp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Timestamp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 seconds = 1;
  void clear_seconds();
  static const int kSecondsFieldNumber = 1;
  ::google::protobuf::int64 seconds() const;
  void set_seconds(::google::protobuf::int64 value);

  // int32 nanos = 2;
  void clear_nanos();
  static const int kNanosFieldNumber = 2;
  ::google::protobuf::int32 nanos() const;
  void set_nanos(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:suil.tmsp.types.Timestamp)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::int64 seconds_;
  ::google::protobuf::int32 nanos_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class Request final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:suil.tmsp.types.Request) */ {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(Request&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Request& default_instance();

  enum ValueCase {
    kEcho = 2,
    kFlush = 3,
    kInfo = 4,
    kSetOption = 5,
    kInitChain = 6,
    kQuery = 7,
    kBeginBlock = 8,
    kCheckTx = 9,
    kDeliverTx = 19,
    kEndBlock = 11,
    kCommit = 12,
    VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Request* other);
  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Request* New() const final {
    return CreateMaybeMessage<Request>(nullptr);
  }

  Request* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Request>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Request* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .suil.tmsp.types.RequestEcho echo = 2;
  bool has_echo() const;
  void clear_echo();
  static const int kEchoFieldNumber = 2;
  const ::suil::tmsp::types::RequestEcho& echo() const;
  ::suil::tmsp::types::RequestEcho* release_echo();
  ::suil::tmsp::types::RequestEcho* mutable_echo();
  void set_allocated_echo(::suil::tmsp::types::RequestEcho* echo);

  // .suil.tmsp.types.RequestFlush flush = 3;
  bool has_flush() const;
  void clear_flush();
  static const int kFlushFieldNumber = 3;
  const ::suil::tmsp::types::RequestFlush& flush() const;
  ::suil::tmsp::types::RequestFlush* release_flush();
  ::suil::tmsp::types::RequestFlush* mutable_flush();
  void set_allocated_flush(::suil::tmsp::types::RequestFlush* flush);

  // .suil.tmsp.types.RequestInfo info = 4;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 4;
  const ::suil::tmsp::types::RequestInfo& info() const;
  ::suil::tmsp::types::RequestInfo* release_info();
  ::suil::tmsp::types::RequestInfo* mutable_info();
  void set_allocated_info(::suil::tmsp::types::RequestInfo* info);

  // .suil.tmsp.types.RequestSetOption set_option = 5;
  bool has_set_option() const;
  void clear_set_option();
  static const int kSetOptionFieldNumber = 5;
  const ::suil::tmsp::types::RequestSetOption& set_option() const;
  ::suil::tmsp::types::RequestSetOption* release_set_option();
  ::suil::tmsp::types::RequestSetOption* mutable_set_option();
  void set_allocated_set_option(::suil::tmsp::types::RequestSetOption* set_option);

  // .suil.tmsp.types.RequestInitChain init_chain = 6;
  bool has_init_chain() const;
  void clear_init_chain();
  static const int kInitChainFieldNumber = 6;
  const ::suil::tmsp::types::RequestInitChain& init_chain() const;
  ::suil::tmsp::types::RequestInitChain* release_init_chain();
  ::suil::tmsp::types::RequestInitChain* mutable_init_chain();
  void set_allocated_init_chain(::suil::tmsp::types::RequestInitChain* init_chain);

  // .suil.tmsp.types.RequestQuery query = 7;
  bool has_query() const;
  void clear_query();
  static const int kQueryFieldNumber = 7;
  const ::suil::tmsp::types::RequestQuery& query() const;
  ::suil::tmsp::types::RequestQuery* release_query();
  ::suil::tmsp::types::RequestQuery* mutable_query();
  void set_allocated_query(::suil::tmsp::types::RequestQuery* query);

  // .suil.tmsp.types.RequestBeginBlock begin_block = 8;
  bool has_begin_block() const;
  void clear_begin_block();
  static const int kBeginBlockFieldNumber = 8;
  const ::suil::tmsp::types::RequestBeginBlock& begin_block() const;
  ::suil::tmsp::types::RequestBeginBlock* release_begin_block();
  ::suil::tmsp::types::RequestBeginBlock* mutable_begin_block();
  void set_allocated_begin_block(::suil::tmsp::types::RequestBeginBlock* begin_block);

  // .suil.tmsp.types.RequestCheckTx check_tx = 9;
  bool has_check_tx() const;
  void clear_check_tx();
  static const int kCheckTxFieldNumber = 9;
  const ::suil::tmsp::types::RequestCheckTx& check_tx() const;
  ::suil::tmsp::types::RequestCheckTx* release_check_tx();
  ::suil::tmsp::types::RequestCheckTx* mutable_check_tx();
  void set_allocated_check_tx(::suil::tmsp::types::RequestCheckTx* check_tx);

  // .suil.tmsp.types.RequestDeliverTx deliver_tx = 19;
  bool has_deliver_tx() const;
  void clear_deliver_tx();
  static const int kDeliverTxFieldNumber = 19;
  const ::suil::tmsp::types::RequestDeliverTx& deliver_tx() const;
  ::suil::tmsp::types::RequestDeliverTx* release_deliver_tx();
  ::suil::tmsp::types::RequestDeliverTx* mutable_deliver_tx();
  void set_allocated_deliver_tx(::suil::tmsp::types::RequestDeliverTx* deliver_tx);

  // .suil.tmsp.types.RequestEndBlock end_block = 11;
  bool has_end_block() const;
  void clear_end_block();
  static const int kEndBlockFieldNumber = 11;
  const ::suil::tmsp::types::RequestEndBlock& end_block() const;
  ::suil::tmsp::types::RequestEndBlock* release_end_block();
  ::suil::tmsp::types::RequestEndBlock* mutable_end_block();
  void set_allocated_end_block(::suil::tmsp::types::RequestEndBlock* end_block);

  // .suil.tmsp.types.RequestCommit commit = 12;
  bool has_commit() const;
  void clear_commit();
  static const int kCommitFieldNumber = 12;
  const ::suil::tmsp::types::RequestCommit& commit() const;
  ::suil::tmsp::types::RequestCommit* release_commit();
  ::suil::tmsp::types::RequestCommit* mutable_commit();
  void set_allocated_commit(::suil::tmsp::types::RequestCommit* commit);

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:suil.tmsp.types.Request)
 private:
  class HasBitSetters;
  void set_has_echo();
  void set_has_flush();
  void set_has_info();
  void set_has_set_option();
  void set_has_init_chain();
  void set_has_query();
  void set_has_begin_block();
  void set_has_check_tx();
  void set_has_deliver_tx();
  void set_has_end_block();
  void set_has_commit();

  inline bool has_value() const;
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  union ValueUnion {
    ValueUnion() {}
    ::suil::tmsp::types::RequestEcho* echo_;
    ::suil::tmsp::types::RequestFlush* flush_;
    ::suil::tmsp::types::RequestInfo* info_;
    ::suil::tmsp::types::RequestSetOption* set_option_;
    ::suil::tmsp::types::RequestInitChain* init_chain_;
    ::suil::tmsp::types::RequestQuery* query_;
    ::suil::tmsp::types::RequestBeginBlock* begin_block_;
    ::suil::tmsp::types::RequestCheckTx* check_tx_;
    ::suil::tmsp::types::RequestDeliverTx* deliver_tx_;
    ::suil::tmsp::types::RequestEndBlock* end_block_;
    ::suil::tmsp::types::RequestCommit* commit_;
  } value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class RequestEcho final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:suil.tmsp.types.RequestEcho) */ {
 public:
  RequestEcho();
  virtual ~RequestEcho();

  RequestEcho(const RequestEcho& from);

  inline RequestEcho& operator=(const RequestEcho& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestEcho(RequestEcho&& from) noexcept
    : RequestEcho() {
    *this = ::std::move(from);
  }

  inline RequestEcho& operator=(RequestEcho&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const RequestEcho& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestEcho* internal_default_instance() {
    return reinterpret_cast<const RequestEcho*>(
               &_RequestEcho_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(RequestEcho* other);
  friend void swap(RequestEcho& a, RequestEcho& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestEcho* New() const final {
    return CreateMaybeMessage<RequestEcho>(nullptr);
  }

  RequestEcho* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestEcho>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const RequestEcho& from);
  void MergeFrom(const RequestEcho& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequestEcho* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 1;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:suil.tmsp.types.RequestEcho)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class RequestFlush final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:suil.tmsp.types.RequestFlush) */ {
 public:
  RequestFlush();
  virtual ~RequestFlush();

  RequestFlush(const RequestFlush& from);

  inline RequestFlush& operator=(const RequestFlush& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestFlush(RequestFlush&& from) noexcept
    : RequestFlush() {
    *this = ::std::move(from);
  }

  inline RequestFlush& operator=(RequestFlush&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const RequestFlush& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestFlush* internal_default_instance() {
    return reinterpret_cast<const RequestFlush*>(
               &_RequestFlush_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(RequestFlush* other);
  friend void swap(RequestFlush& a, RequestFlush& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestFlush* New() const final {
    return CreateMaybeMessage<RequestFlush>(nullptr);
  }

  RequestFlush* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestFlush>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const RequestFlush& from);
  void MergeFrom(const RequestFlush& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequestFlush* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:suil.tmsp.types.RequestFlush)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class RequestInfo final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:suil.tmsp.types.RequestInfo) */ {
 public:
  RequestInfo();
  virtual ~RequestInfo();

  RequestInfo(const RequestInfo& from);

  inline RequestInfo& operator=(const RequestInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestInfo(RequestInfo&& from) noexcept
    : RequestInfo() {
    *this = ::std::move(from);
  }

  inline RequestInfo& operator=(RequestInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const RequestInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestInfo* internal_default_instance() {
    return reinterpret_cast<const RequestInfo*>(
               &_RequestInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(RequestInfo* other);
  friend void swap(RequestInfo& a, RequestInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestInfo* New() const final {
    return CreateMaybeMessage<RequestInfo>(nullptr);
  }

  RequestInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const RequestInfo& from);
  void MergeFrom(const RequestInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequestInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string version = 1;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // uint64 block_version = 2;
  void clear_block_version();
  static const int kBlockVersionFieldNumber = 2;
  ::google::protobuf::uint64 block_version() const;
  void set_block_version(::google::protobuf::uint64 value);

  // uint64 p2p_version = 3;
  void clear_p2p_version();
  static const int kP2PVersionFieldNumber = 3;
  ::google::protobuf::uint64 p2p_version() const;
  void set_p2p_version(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:suil.tmsp.types.RequestInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::uint64 block_version_;
  ::google::protobuf::uint64 p2p_version_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class RequestSetOption final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:suil.tmsp.types.RequestSetOption) */ {
 public:
  RequestSetOption();
  virtual ~RequestSetOption();

  RequestSetOption(const RequestSetOption& from);

  inline RequestSetOption& operator=(const RequestSetOption& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestSetOption(RequestSetOption&& from) noexcept
    : RequestSetOption() {
    *this = ::std::move(from);
  }

  inline RequestSetOption& operator=(RequestSetOption&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const RequestSetOption& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestSetOption* internal_default_instance() {
    return reinterpret_cast<const RequestSetOption*>(
               &_RequestSetOption_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(RequestSetOption* other);
  friend void swap(RequestSetOption& a, RequestSetOption& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestSetOption* New() const final {
    return CreateMaybeMessage<RequestSetOption>(nullptr);
  }

  RequestSetOption* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestSetOption>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const RequestSetOption& from);
  void MergeFrom(const RequestSetOption& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequestSetOption* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:suil.tmsp.types.RequestSetOption)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class RequestInitChain final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:suil.tmsp.types.RequestInitChain) */ {
 public:
  RequestInitChain();
  virtual ~RequestInitChain();

  RequestInitChain(const RequestInitChain& from);

  inline RequestInitChain& operator=(const RequestInitChain& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestInitChain(RequestInitChain&& from) noexcept
    : RequestInitChain() {
    *this = ::std::move(from);
  }

  inline RequestInitChain& operator=(RequestInitChain&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const RequestInitChain& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestInitChain* internal_default_instance() {
    return reinterpret_cast<const RequestInitChain*>(
               &_RequestInitChain_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(RequestInitChain* other);
  friend void swap(RequestInitChain& a, RequestInitChain& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestInitChain* New() const final {
    return CreateMaybeMessage<RequestInitChain>(nullptr);
  }

  RequestInitChain* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestInitChain>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const RequestInitChain& from);
  void MergeFrom(const RequestInitChain& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequestInitChain* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .suil.tmsp.types.ValidatorUpdate validators = 4;
  int validators_size() const;
  void clear_validators();
  static const int kValidatorsFieldNumber = 4;
  ::suil::tmsp::types::ValidatorUpdate* mutable_validators(int index);
  ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::ValidatorUpdate >*
      mutable_validators();
  const ::suil::tmsp::types::ValidatorUpdate& validators(int index) const;
  ::suil::tmsp::types::ValidatorUpdate* add_validators();
  const ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::ValidatorUpdate >&
      validators() const;

  // string chain_id = 2;
  void clear_chain_id();
  static const int kChainIdFieldNumber = 2;
  const ::std::string& chain_id() const;
  void set_chain_id(const ::std::string& value);
  #if LANG_CXX11
  void set_chain_id(::std::string&& value);
  #endif
  void set_chain_id(const char* value);
  void set_chain_id(const char* value, size_t size);
  ::std::string* mutable_chain_id();
  ::std::string* release_chain_id();
  void set_allocated_chain_id(::std::string* chain_id);

  // bytes app_state_bytes = 5;
  void clear_app_state_bytes();
  static const int kAppStateBytesFieldNumber = 5;
  const ::std::string& app_state_bytes() const;
  void set_app_state_bytes(const ::std::string& value);
  #if LANG_CXX11
  void set_app_state_bytes(::std::string&& value);
  #endif
  void set_app_state_bytes(const char* value);
  void set_app_state_bytes(const void* value, size_t size);
  ::std::string* mutable_app_state_bytes();
  ::std::string* release_app_state_bytes();
  void set_allocated_app_state_bytes(::std::string* app_state_bytes);

  // .suil.tmsp.types.Timestamp time = 1;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 1;
  const ::suil::tmsp::types::Timestamp& time() const;
  ::suil::tmsp::types::Timestamp* release_time();
  ::suil::tmsp::types::Timestamp* mutable_time();
  void set_allocated_time(::suil::tmsp::types::Timestamp* time);

  // .suil.tmsp.types.ConsensusParams consensus_params = 3;
  bool has_consensus_params() const;
  void clear_consensus_params();
  static const int kConsensusParamsFieldNumber = 3;
  const ::suil::tmsp::types::ConsensusParams& consensus_params() const;
  ::suil::tmsp::types::ConsensusParams* release_consensus_params();
  ::suil::tmsp::types::ConsensusParams* mutable_consensus_params();
  void set_allocated_consensus_params(::suil::tmsp::types::ConsensusParams* consensus_params);

  // @@protoc_insertion_point(class_scope:suil.tmsp.types.RequestInitChain)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::ValidatorUpdate > validators_;
  ::google::protobuf::internal::ArenaStringPtr chain_id_;
  ::google::protobuf::internal::ArenaStringPtr app_state_bytes_;
  ::suil::tmsp::types::Timestamp* time_;
  ::suil::tmsp::types::ConsensusParams* consensus_params_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class RequestQuery final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:suil.tmsp.types.RequestQuery) */ {
 public:
  RequestQuery();
  virtual ~RequestQuery();

  RequestQuery(const RequestQuery& from);

  inline RequestQuery& operator=(const RequestQuery& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestQuery(RequestQuery&& from) noexcept
    : RequestQuery() {
    *this = ::std::move(from);
  }

  inline RequestQuery& operator=(RequestQuery&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const RequestQuery& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestQuery* internal_default_instance() {
    return reinterpret_cast<const RequestQuery*>(
               &_RequestQuery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(RequestQuery* other);
  friend void swap(RequestQuery& a, RequestQuery& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestQuery* New() const final {
    return CreateMaybeMessage<RequestQuery>(nullptr);
  }

  RequestQuery* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestQuery>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const RequestQuery& from);
  void MergeFrom(const RequestQuery& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequestQuery* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes data = 1;
  void clear_data();
  static const int kDataFieldNumber = 1;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // string path = 2;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // int64 height = 3;
  void clear_height();
  static const int kHeightFieldNumber = 3;
  ::google::protobuf::int64 height() const;
  void set_height(::google::protobuf::int64 value);

  // bool prove = 4;
  void clear_prove();
  static const int kProveFieldNumber = 4;
  bool prove() const;
  void set_prove(bool value);

  // @@protoc_insertion_point(class_scope:suil.tmsp.types.RequestQuery)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::int64 height_;
  bool prove_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class RequestBeginBlock final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:suil.tmsp.types.RequestBeginBlock) */ {
 public:
  RequestBeginBlock();
  virtual ~RequestBeginBlock();

  RequestBeginBlock(const RequestBeginBlock& from);

  inline RequestBeginBlock& operator=(const RequestBeginBlock& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestBeginBlock(RequestBeginBlock&& from) noexcept
    : RequestBeginBlock() {
    *this = ::std::move(from);
  }

  inline RequestBeginBlock& operator=(RequestBeginBlock&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const RequestBeginBlock& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestBeginBlock* internal_default_instance() {
    return reinterpret_cast<const RequestBeginBlock*>(
               &_RequestBeginBlock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(RequestBeginBlock* other);
  friend void swap(RequestBeginBlock& a, RequestBeginBlock& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestBeginBlock* New() const final {
    return CreateMaybeMessage<RequestBeginBlock>(nullptr);
  }

  RequestBeginBlock* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestBeginBlock>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const RequestBeginBlock& from);
  void MergeFrom(const RequestBeginBlock& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequestBeginBlock* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .suil.tmsp.types.Evidence byzantine_validators = 4;
  int byzantine_validators_size() const;
  void clear_byzantine_validators();
  static const int kByzantineValidatorsFieldNumber = 4;
  ::suil::tmsp::types::Evidence* mutable_byzantine_validators(int index);
  ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::Evidence >*
      mutable_byzantine_validators();
  const ::suil::tmsp::types::Evidence& byzantine_validators(int index) const;
  ::suil::tmsp::types::Evidence* add_byzantine_validators();
  const ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::Evidence >&
      byzantine_validators() const;

  // bytes hash = 1;
  void clear_hash();
  static const int kHashFieldNumber = 1;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // .suil.tmsp.types.Header header = 2;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 2;
  const ::suil::tmsp::types::Header& header() const;
  ::suil::tmsp::types::Header* release_header();
  ::suil::tmsp::types::Header* mutable_header();
  void set_allocated_header(::suil::tmsp::types::Header* header);

  // .suil.tmsp.types.LastCommitInfo last_commit_info = 3;
  bool has_last_commit_info() const;
  void clear_last_commit_info();
  static const int kLastCommitInfoFieldNumber = 3;
  const ::suil::tmsp::types::LastCommitInfo& last_commit_info() const;
  ::suil::tmsp::types::LastCommitInfo* release_last_commit_info();
  ::suil::tmsp::types::LastCommitInfo* mutable_last_commit_info();
  void set_allocated_last_commit_info(::suil::tmsp::types::LastCommitInfo* last_commit_info);

  // @@protoc_insertion_point(class_scope:suil.tmsp.types.RequestBeginBlock)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::Evidence > byzantine_validators_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::suil::tmsp::types::Header* header_;
  ::suil::tmsp::types::LastCommitInfo* last_commit_info_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class RequestCheckTx final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:suil.tmsp.types.RequestCheckTx) */ {
 public:
  RequestCheckTx();
  virtual ~RequestCheckTx();

  RequestCheckTx(const RequestCheckTx& from);

  inline RequestCheckTx& operator=(const RequestCheckTx& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestCheckTx(RequestCheckTx&& from) noexcept
    : RequestCheckTx() {
    *this = ::std::move(from);
  }

  inline RequestCheckTx& operator=(RequestCheckTx&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const RequestCheckTx& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestCheckTx* internal_default_instance() {
    return reinterpret_cast<const RequestCheckTx*>(
               &_RequestCheckTx_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(RequestCheckTx* other);
  friend void swap(RequestCheckTx& a, RequestCheckTx& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestCheckTx* New() const final {
    return CreateMaybeMessage<RequestCheckTx>(nullptr);
  }

  RequestCheckTx* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestCheckTx>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const RequestCheckTx& from);
  void MergeFrom(const RequestCheckTx& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequestCheckTx* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes tx = 1;
  void clear_tx();
  static const int kTxFieldNumber = 1;
  const ::std::string& tx() const;
  void set_tx(const ::std::string& value);
  #if LANG_CXX11
  void set_tx(::std::string&& value);
  #endif
  void set_tx(const char* value);
  void set_tx(const void* value, size_t size);
  ::std::string* mutable_tx();
  ::std::string* release_tx();
  void set_allocated_tx(::std::string* tx);

  // @@protoc_insertion_point(class_scope:suil.tmsp.types.RequestCheckTx)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr tx_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class RequestDeliverTx final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:suil.tmsp.types.RequestDeliverTx) */ {
 public:
  RequestDeliverTx();
  virtual ~RequestDeliverTx();

  RequestDeliverTx(const RequestDeliverTx& from);

  inline RequestDeliverTx& operator=(const RequestDeliverTx& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestDeliverTx(RequestDeliverTx&& from) noexcept
    : RequestDeliverTx() {
    *this = ::std::move(from);
  }

  inline RequestDeliverTx& operator=(RequestDeliverTx&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const RequestDeliverTx& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestDeliverTx* internal_default_instance() {
    return reinterpret_cast<const RequestDeliverTx*>(
               &_RequestDeliverTx_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(RequestDeliverTx* other);
  friend void swap(RequestDeliverTx& a, RequestDeliverTx& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestDeliverTx* New() const final {
    return CreateMaybeMessage<RequestDeliverTx>(nullptr);
  }

  RequestDeliverTx* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestDeliverTx>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const RequestDeliverTx& from);
  void MergeFrom(const RequestDeliverTx& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequestDeliverTx* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes tx = 1;
  void clear_tx();
  static const int kTxFieldNumber = 1;
  const ::std::string& tx() const;
  void set_tx(const ::std::string& value);
  #if LANG_CXX11
  void set_tx(::std::string&& value);
  #endif
  void set_tx(const char* value);
  void set_tx(const void* value, size_t size);
  ::std::string* mutable_tx();
  ::std::string* release_tx();
  void set_allocated_tx(::std::string* tx);

  // @@protoc_insertion_point(class_scope:suil.tmsp.types.RequestDeliverTx)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr tx_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class RequestEndBlock final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:suil.tmsp.types.RequestEndBlock) */ {
 public:
  RequestEndBlock();
  virtual ~RequestEndBlock();

  RequestEndBlock(const RequestEndBlock& from);

  inline RequestEndBlock& operator=(const RequestEndBlock& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestEndBlock(RequestEndBlock&& from) noexcept
    : RequestEndBlock() {
    *this = ::std::move(from);
  }

  inline RequestEndBlock& operator=(RequestEndBlock&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const RequestEndBlock& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestEndBlock* internal_default_instance() {
    return reinterpret_cast<const RequestEndBlock*>(
               &_RequestEndBlock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(RequestEndBlock* other);
  friend void swap(RequestEndBlock& a, RequestEndBlock& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestEndBlock* New() const final {
    return CreateMaybeMessage<RequestEndBlock>(nullptr);
  }

  RequestEndBlock* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestEndBlock>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const RequestEndBlock& from);
  void MergeFrom(const RequestEndBlock& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequestEndBlock* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 height = 1;
  void clear_height();
  static const int kHeightFieldNumber = 1;
  ::google::protobuf::int64 height() const;
  void set_height(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:suil.tmsp.types.RequestEndBlock)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::int64 height_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class RequestCommit final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:suil.tmsp.types.RequestCommit) */ {
 public:
  RequestCommit();
  virtual ~RequestCommit();

  RequestCommit(const RequestCommit& from);

  inline RequestCommit& operator=(const RequestCommit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestCommit(RequestCommit&& from) noexcept
    : RequestCommit() {
    *this = ::std::move(from);
  }

  inline RequestCommit& operator=(RequestCommit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const RequestCommit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestCommit* internal_default_instance() {
    return reinterpret_cast<const RequestCommit*>(
               &_RequestCommit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(RequestCommit* other);
  friend void swap(RequestCommit& a, RequestCommit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestCommit* New() const final {
    return CreateMaybeMessage<RequestCommit>(nullptr);
  }

  RequestCommit* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestCommit>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const RequestCommit& from);
  void MergeFrom(const RequestCommit& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequestCommit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:suil.tmsp.types.RequestCommit)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class Response final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:suil.tmsp.types.Response) */ {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Response& default_instance();

  enum ValueCase {
    kException = 1,
    kEcho = 2,
    kFlush = 3,
    kInfo = 4,
    kSetOption = 5,
    kInitChain = 6,
    kQuery = 7,
    kBeginBlock = 8,
    kCheckTx = 9,
    kDeliverTx = 10,
    kEndBlock = 11,
    kCommit = 12,
    VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(Response* other);
  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response* New() const final {
    return CreateMaybeMessage<Response>(nullptr);
  }

  Response* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Response>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .suil.tmsp.types.ResponseException exception = 1;
  bool has_exception() const;
  void clear_exception();
  static const int kExceptionFieldNumber = 1;
  const ::suil::tmsp::types::ResponseException& exception() const;
  ::suil::tmsp::types::ResponseException* release_exception();
  ::suil::tmsp::types::ResponseException* mutable_exception();
  void set_allocated_exception(::suil::tmsp::types::ResponseException* exception);

  // .suil.tmsp.types.ResponseEcho echo = 2;
  bool has_echo() const;
  void clear_echo();
  static const int kEchoFieldNumber = 2;
  const ::suil::tmsp::types::ResponseEcho& echo() const;
  ::suil::tmsp::types::ResponseEcho* release_echo();
  ::suil::tmsp::types::ResponseEcho* mutable_echo();
  void set_allocated_echo(::suil::tmsp::types::ResponseEcho* echo);

  // .suil.tmsp.types.ResponseFlush flush = 3;
  bool has_flush() const;
  void clear_flush();
  static const int kFlushFieldNumber = 3;
  const ::suil::tmsp::types::ResponseFlush& flush() const;
  ::suil::tmsp::types::ResponseFlush* release_flush();
  ::suil::tmsp::types::ResponseFlush* mutable_flush();
  void set_allocated_flush(::suil::tmsp::types::ResponseFlush* flush);

  // .suil.tmsp.types.ResponseInfo info = 4;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 4;
  const ::suil::tmsp::types::ResponseInfo& info() const;
  ::suil::tmsp::types::ResponseInfo* release_info();
  ::suil::tmsp::types::ResponseInfo* mutable_info();
  void set_allocated_info(::suil::tmsp::types::ResponseInfo* info);

  // .suil.tmsp.types.ResponseSetOption set_option = 5;
  bool has_set_option() const;
  void clear_set_option();
  static const int kSetOptionFieldNumber = 5;
  const ::suil::tmsp::types::ResponseSetOption& set_option() const;
  ::suil::tmsp::types::ResponseSetOption* release_set_option();
  ::suil::tmsp::types::ResponseSetOption* mutable_set_option();
  void set_allocated_set_option(::suil::tmsp::types::ResponseSetOption* set_option);

  // .suil.tmsp.types.ResponseInitChain init_chain = 6;
  bool has_init_chain() const;
  void clear_init_chain();
  static const int kInitChainFieldNumber = 6;
  const ::suil::tmsp::types::ResponseInitChain& init_chain() const;
  ::suil::tmsp::types::ResponseInitChain* release_init_chain();
  ::suil::tmsp::types::ResponseInitChain* mutable_init_chain();
  void set_allocated_init_chain(::suil::tmsp::types::ResponseInitChain* init_chain);

  // .suil.tmsp.types.ResponseQuery query = 7;
  bool has_query() const;
  void clear_query();
  static const int kQueryFieldNumber = 7;
  const ::suil::tmsp::types::ResponseQuery& query() const;
  ::suil::tmsp::types::ResponseQuery* release_query();
  ::suil::tmsp::types::ResponseQuery* mutable_query();
  void set_allocated_query(::suil::tmsp::types::ResponseQuery* query);

  // .suil.tmsp.types.ResponseBeginBlock begin_block = 8;
  bool has_begin_block() const;
  void clear_begin_block();
  static const int kBeginBlockFieldNumber = 8;
  const ::suil::tmsp::types::ResponseBeginBlock& begin_block() const;
  ::suil::tmsp::types::ResponseBeginBlock* release_begin_block();
  ::suil::tmsp::types::ResponseBeginBlock* mutable_begin_block();
  void set_allocated_begin_block(::suil::tmsp::types::ResponseBeginBlock* begin_block);

  // .suil.tmsp.types.ResponseCheckTx check_tx = 9;
  bool has_check_tx() const;
  void clear_check_tx();
  static const int kCheckTxFieldNumber = 9;
  const ::suil::tmsp::types::ResponseCheckTx& check_tx() const;
  ::suil::tmsp::types::ResponseCheckTx* release_check_tx();
  ::suil::tmsp::types::ResponseCheckTx* mutable_check_tx();
  void set_allocated_check_tx(::suil::tmsp::types::ResponseCheckTx* check_tx);

  // .suil.tmsp.types.ResponseDeliverTx deliver_tx = 10;
  bool has_deliver_tx() const;
  void clear_deliver_tx();
  static const int kDeliverTxFieldNumber = 10;
  const ::suil::tmsp::types::ResponseDeliverTx& deliver_tx() const;
  ::suil::tmsp::types::ResponseDeliverTx* release_deliver_tx();
  ::suil::tmsp::types::ResponseDeliverTx* mutable_deliver_tx();
  void set_allocated_deliver_tx(::suil::tmsp::types::ResponseDeliverTx* deliver_tx);

  // .suil.tmsp.types.ResponseEndBlock end_block = 11;
  bool has_end_block() const;
  void clear_end_block();
  static const int kEndBlockFieldNumber = 11;
  const ::suil::tmsp::types::ResponseEndBlock& end_block() const;
  ::suil::tmsp::types::ResponseEndBlock* release_end_block();
  ::suil::tmsp::types::ResponseEndBlock* mutable_end_block();
  void set_allocated_end_block(::suil::tmsp::types::ResponseEndBlock* end_block);

  // .suil.tmsp.types.ResponseCommit commit = 12;
  bool has_commit() const;
  void clear_commit();
  static const int kCommitFieldNumber = 12;
  const ::suil::tmsp::types::ResponseCommit& commit() const;
  ::suil::tmsp::types::ResponseCommit* release_commit();
  ::suil::tmsp::types::ResponseCommit* mutable_commit();
  void set_allocated_commit(::suil::tmsp::types::ResponseCommit* commit);

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:suil.tmsp.types.Response)
 private:
  class HasBitSetters;
  void set_has_exception();
  void set_has_echo();
  void set_has_flush();
  void set_has_info();
  void set_has_set_option();
  void set_has_init_chain();
  void set_has_query();
  void set_has_begin_block();
  void set_has_check_tx();
  void set_has_deliver_tx();
  void set_has_end_block();
  void set_has_commit();

  inline bool has_value() const;
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  union ValueUnion {
    ValueUnion() {}
    ::suil::tmsp::types::ResponseException* exception_;
    ::suil::tmsp::types::ResponseEcho* echo_;
    ::suil::tmsp::types::ResponseFlush* flush_;
    ::suil::tmsp::types::ResponseInfo* info_;
    ::suil::tmsp::types::ResponseSetOption* set_option_;
    ::suil::tmsp::types::ResponseInitChain* init_chain_;
    ::suil::tmsp::types::ResponseQuery* query_;
    ::suil::tmsp::types::ResponseBeginBlock* begin_block_;
    ::suil::tmsp::types::ResponseCheckTx* check_tx_;
    ::suil::tmsp::types::ResponseDeliverTx* deliver_tx_;
    ::suil::tmsp::types::ResponseEndBlock* end_block_;
    ::suil::tmsp::types::ResponseCommit* commit_;
  } value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class ResponseException final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:suil.tmsp.types.ResponseException) */ {
 public:
  ResponseException();
  virtual ~ResponseException();

  ResponseException(const ResponseException& from);

  inline ResponseException& operator=(const ResponseException& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseException(ResponseException&& from) noexcept
    : ResponseException() {
    *this = ::std::move(from);
  }

  inline ResponseException& operator=(ResponseException&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ResponseException& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseException* internal_default_instance() {
    return reinterpret_cast<const ResponseException*>(
               &_ResponseException_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(ResponseException* other);
  friend void swap(ResponseException& a, ResponseException& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseException* New() const final {
    return CreateMaybeMessage<ResponseException>(nullptr);
  }

  ResponseException* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseException>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ResponseException& from);
  void MergeFrom(const ResponseException& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResponseException* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string error = 1;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  #if LANG_CXX11
  void set_error(::std::string&& value);
  #endif
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // @@protoc_insertion_point(class_scope:suil.tmsp.types.ResponseException)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class ResponseEcho final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:suil.tmsp.types.ResponseEcho) */ {
 public:
  ResponseEcho();
  virtual ~ResponseEcho();

  ResponseEcho(const ResponseEcho& from);

  inline ResponseEcho& operator=(const ResponseEcho& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseEcho(ResponseEcho&& from) noexcept
    : ResponseEcho() {
    *this = ::std::move(from);
  }

  inline ResponseEcho& operator=(ResponseEcho&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ResponseEcho& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseEcho* internal_default_instance() {
    return reinterpret_cast<const ResponseEcho*>(
               &_ResponseEcho_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(ResponseEcho* other);
  friend void swap(ResponseEcho& a, ResponseEcho& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseEcho* New() const final {
    return CreateMaybeMessage<ResponseEcho>(nullptr);
  }

  ResponseEcho* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseEcho>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ResponseEcho& from);
  void MergeFrom(const ResponseEcho& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResponseEcho* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 1;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:suil.tmsp.types.ResponseEcho)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class ResponseFlush final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:suil.tmsp.types.ResponseFlush) */ {
 public:
  ResponseFlush();
  virtual ~ResponseFlush();

  ResponseFlush(const ResponseFlush& from);

  inline ResponseFlush& operator=(const ResponseFlush& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseFlush(ResponseFlush&& from) noexcept
    : ResponseFlush() {
    *this = ::std::move(from);
  }

  inline ResponseFlush& operator=(ResponseFlush&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ResponseFlush& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseFlush* internal_default_instance() {
    return reinterpret_cast<const ResponseFlush*>(
               &_ResponseFlush_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(ResponseFlush* other);
  friend void swap(ResponseFlush& a, ResponseFlush& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseFlush* New() const final {
    return CreateMaybeMessage<ResponseFlush>(nullptr);
  }

  ResponseFlush* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseFlush>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ResponseFlush& from);
  void MergeFrom(const ResponseFlush& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResponseFlush* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:suil.tmsp.types.ResponseFlush)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class ResponseInfo final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:suil.tmsp.types.ResponseInfo) */ {
 public:
  ResponseInfo();
  virtual ~ResponseInfo();

  ResponseInfo(const ResponseInfo& from);

  inline ResponseInfo& operator=(const ResponseInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseInfo(ResponseInfo&& from) noexcept
    : ResponseInfo() {
    *this = ::std::move(from);
  }

  inline ResponseInfo& operator=(ResponseInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ResponseInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseInfo* internal_default_instance() {
    return reinterpret_cast<const ResponseInfo*>(
               &_ResponseInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(ResponseInfo* other);
  friend void swap(ResponseInfo& a, ResponseInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseInfo* New() const final {
    return CreateMaybeMessage<ResponseInfo>(nullptr);
  }

  ResponseInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ResponseInfo& from);
  void MergeFrom(const ResponseInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResponseInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string data = 1;
  void clear_data();
  static const int kDataFieldNumber = 1;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const char* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // string version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // bytes last_block_app_hash = 5;
  void clear_last_block_app_hash();
  static const int kLastBlockAppHashFieldNumber = 5;
  const ::std::string& last_block_app_hash() const;
  void set_last_block_app_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_last_block_app_hash(::std::string&& value);
  #endif
  void set_last_block_app_hash(const char* value);
  void set_last_block_app_hash(const void* value, size_t size);
  ::std::string* mutable_last_block_app_hash();
  ::std::string* release_last_block_app_hash();
  void set_allocated_last_block_app_hash(::std::string* last_block_app_hash);

  // uint64 app_version = 3;
  void clear_app_version();
  static const int kAppVersionFieldNumber = 3;
  ::google::protobuf::uint64 app_version() const;
  void set_app_version(::google::protobuf::uint64 value);

  // int64 last_block_height = 4;
  void clear_last_block_height();
  static const int kLastBlockHeightFieldNumber = 4;
  ::google::protobuf::int64 last_block_height() const;
  void set_last_block_height(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:suil.tmsp.types.ResponseInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr last_block_app_hash_;
  ::google::protobuf::uint64 app_version_;
  ::google::protobuf::int64 last_block_height_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class ResponseSetOption final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:suil.tmsp.types.ResponseSetOption) */ {
 public:
  ResponseSetOption();
  virtual ~ResponseSetOption();

  ResponseSetOption(const ResponseSetOption& from);

  inline ResponseSetOption& operator=(const ResponseSetOption& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseSetOption(ResponseSetOption&& from) noexcept
    : ResponseSetOption() {
    *this = ::std::move(from);
  }

  inline ResponseSetOption& operator=(ResponseSetOption&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ResponseSetOption& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseSetOption* internal_default_instance() {
    return reinterpret_cast<const ResponseSetOption*>(
               &_ResponseSetOption_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(ResponseSetOption* other);
  friend void swap(ResponseSetOption& a, ResponseSetOption& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseSetOption* New() const final {
    return CreateMaybeMessage<ResponseSetOption>(nullptr);
  }

  ResponseSetOption* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseSetOption>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ResponseSetOption& from);
  void MergeFrom(const ResponseSetOption& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResponseSetOption* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string log = 3;
  void clear_log();
  static const int kLogFieldNumber = 3;
  const ::std::string& log() const;
  void set_log(const ::std::string& value);
  #if LANG_CXX11
  void set_log(::std::string&& value);
  #endif
  void set_log(const char* value);
  void set_log(const char* value, size_t size);
  ::std::string* mutable_log();
  ::std::string* release_log();
  void set_allocated_log(::std::string* log);

  // string info = 4;
  void clear_info();
  static const int kInfoFieldNumber = 4;
  const ::std::string& info() const;
  void set_info(const ::std::string& value);
  #if LANG_CXX11
  void set_info(::std::string&& value);
  #endif
  void set_info(const char* value);
  void set_info(const char* value, size_t size);
  ::std::string* mutable_info();
  ::std::string* release_info();
  void set_allocated_info(::std::string* info);

  // uint32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::uint32 code() const;
  void set_code(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:suil.tmsp.types.ResponseSetOption)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr log_;
  ::google::protobuf::internal::ArenaStringPtr info_;
  ::google::protobuf::uint32 code_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class ResponseInitChain final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:suil.tmsp.types.ResponseInitChain) */ {
 public:
  ResponseInitChain();
  virtual ~ResponseInitChain();

  ResponseInitChain(const ResponseInitChain& from);

  inline ResponseInitChain& operator=(const ResponseInitChain& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseInitChain(ResponseInitChain&& from) noexcept
    : ResponseInitChain() {
    *this = ::std::move(from);
  }

  inline ResponseInitChain& operator=(ResponseInitChain&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ResponseInitChain& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseInitChain* internal_default_instance() {
    return reinterpret_cast<const ResponseInitChain*>(
               &_ResponseInitChain_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(ResponseInitChain* other);
  friend void swap(ResponseInitChain& a, ResponseInitChain& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseInitChain* New() const final {
    return CreateMaybeMessage<ResponseInitChain>(nullptr);
  }

  ResponseInitChain* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseInitChain>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ResponseInitChain& from);
  void MergeFrom(const ResponseInitChain& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResponseInitChain* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .suil.tmsp.types.ValidatorUpdate validators = 2;
  int validators_size() const;
  void clear_validators();
  static const int kValidatorsFieldNumber = 2;
  ::suil::tmsp::types::ValidatorUpdate* mutable_validators(int index);
  ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::ValidatorUpdate >*
      mutable_validators();
  const ::suil::tmsp::types::ValidatorUpdate& validators(int index) const;
  ::suil::tmsp::types::ValidatorUpdate* add_validators();
  const ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::ValidatorUpdate >&
      validators() const;

  // .suil.tmsp.types.ConsensusParams consensus_params = 1;
  bool has_consensus_params() const;
  void clear_consensus_params();
  static const int kConsensusParamsFieldNumber = 1;
  const ::suil::tmsp::types::ConsensusParams& consensus_params() const;
  ::suil::tmsp::types::ConsensusParams* release_consensus_params();
  ::suil::tmsp::types::ConsensusParams* mutable_consensus_params();
  void set_allocated_consensus_params(::suil::tmsp::types::ConsensusParams* consensus_params);

  // @@protoc_insertion_point(class_scope:suil.tmsp.types.ResponseInitChain)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::ValidatorUpdate > validators_;
  ::suil::tmsp::types::ConsensusParams* consensus_params_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class ResponseQuery final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:suil.tmsp.types.ResponseQuery) */ {
 public:
  ResponseQuery();
  virtual ~ResponseQuery();

  ResponseQuery(const ResponseQuery& from);

  inline ResponseQuery& operator=(const ResponseQuery& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseQuery(ResponseQuery&& from) noexcept
    : ResponseQuery() {
    *this = ::std::move(from);
  }

  inline ResponseQuery& operator=(ResponseQuery&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ResponseQuery& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseQuery* internal_default_instance() {
    return reinterpret_cast<const ResponseQuery*>(
               &_ResponseQuery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(ResponseQuery* other);
  friend void swap(ResponseQuery& a, ResponseQuery& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseQuery* New() const final {
    return CreateMaybeMessage<ResponseQuery>(nullptr);
  }

  ResponseQuery* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseQuery>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ResponseQuery& from);
  void MergeFrom(const ResponseQuery& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResponseQuery* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string log = 3;
  void clear_log();
  static const int kLogFieldNumber = 3;
  const ::std::string& log() const;
  void set_log(const ::std::string& value);
  #if LANG_CXX11
  void set_log(::std::string&& value);
  #endif
  void set_log(const char* value);
  void set_log(const char* value, size_t size);
  ::std::string* mutable_log();
  ::std::string* release_log();
  void set_allocated_log(::std::string* log);

  // string info = 4;
  void clear_info();
  static const int kInfoFieldNumber = 4;
  const ::std::string& info() const;
  void set_info(const ::std::string& value);
  #if LANG_CXX11
  void set_info(::std::string&& value);
  #endif
  void set_info(const char* value);
  void set_info(const char* value, size_t size);
  ::std::string* mutable_info();
  ::std::string* release_info();
  void set_allocated_info(::std::string* info);

  // bytes key = 6;
  void clear_key();
  static const int kKeyFieldNumber = 6;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // bytes value = 7;
  void clear_value();
  static const int kValueFieldNumber = 7;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // string codespace = 10;
  void clear_codespace();
  static const int kCodespaceFieldNumber = 10;
  const ::std::string& codespace() const;
  void set_codespace(const ::std::string& value);
  #if LANG_CXX11
  void set_codespace(::std::string&& value);
  #endif
  void set_codespace(const char* value);
  void set_codespace(const char* value, size_t size);
  ::std::string* mutable_codespace();
  ::std::string* release_codespace();
  void set_allocated_codespace(::std::string* codespace);

  // .suil.tmsp.types.Proof proof = 8;
  bool has_proof() const;
  void clear_proof();
  static const int kProofFieldNumber = 8;
  const ::suil::tmsp::types::Proof& proof() const;
  ::suil::tmsp::types::Proof* release_proof();
  ::suil::tmsp::types::Proof* mutable_proof();
  void set_allocated_proof(::suil::tmsp::types::Proof* proof);

  // int64 index = 5;
  void clear_index();
  static const int kIndexFieldNumber = 5;
  ::google::protobuf::int64 index() const;
  void set_index(::google::protobuf::int64 value);

  // int64 height = 9;
  void clear_height();
  static const int kHeightFieldNumber = 9;
  ::google::protobuf::int64 height() const;
  void set_height(::google::protobuf::int64 value);

  // uint32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::uint32 code() const;
  void set_code(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:suil.tmsp.types.ResponseQuery)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr log_;
  ::google::protobuf::internal::ArenaStringPtr info_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::internal::ArenaStringPtr codespace_;
  ::suil::tmsp::types::Proof* proof_;
  ::google::protobuf::int64 index_;
  ::google::protobuf::int64 height_;
  ::google::protobuf::uint32 code_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class ResponseBeginBlock final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:suil.tmsp.types.ResponseBeginBlock) */ {
 public:
  ResponseBeginBlock();
  virtual ~ResponseBeginBlock();

  ResponseBeginBlock(const ResponseBeginBlock& from);

  inline ResponseBeginBlock& operator=(const ResponseBeginBlock& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseBeginBlock(ResponseBeginBlock&& from) noexcept
    : ResponseBeginBlock() {
    *this = ::std::move(from);
  }

  inline ResponseBeginBlock& operator=(ResponseBeginBlock&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ResponseBeginBlock& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseBeginBlock* internal_default_instance() {
    return reinterpret_cast<const ResponseBeginBlock*>(
               &_ResponseBeginBlock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(ResponseBeginBlock* other);
  friend void swap(ResponseBeginBlock& a, ResponseBeginBlock& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseBeginBlock* New() const final {
    return CreateMaybeMessage<ResponseBeginBlock>(nullptr);
  }

  ResponseBeginBlock* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseBeginBlock>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ResponseBeginBlock& from);
  void MergeFrom(const ResponseBeginBlock& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResponseBeginBlock* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .suil.tmsp.types.KVPair tags = 1;
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 1;
  ::suil::tmsp::types::KVPair* mutable_tags(int index);
  ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::KVPair >*
      mutable_tags();
  const ::suil::tmsp::types::KVPair& tags(int index) const;
  ::suil::tmsp::types::KVPair* add_tags();
  const ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::KVPair >&
      tags() const;

  // @@protoc_insertion_point(class_scope:suil.tmsp.types.ResponseBeginBlock)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::KVPair > tags_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class ResponseCheckTx final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:suil.tmsp.types.ResponseCheckTx) */ {
 public:
  ResponseCheckTx();
  virtual ~ResponseCheckTx();

  ResponseCheckTx(const ResponseCheckTx& from);

  inline ResponseCheckTx& operator=(const ResponseCheckTx& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseCheckTx(ResponseCheckTx&& from) noexcept
    : ResponseCheckTx() {
    *this = ::std::move(from);
  }

  inline ResponseCheckTx& operator=(ResponseCheckTx&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ResponseCheckTx& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseCheckTx* internal_default_instance() {
    return reinterpret_cast<const ResponseCheckTx*>(
               &_ResponseCheckTx_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(ResponseCheckTx* other);
  friend void swap(ResponseCheckTx& a, ResponseCheckTx& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseCheckTx* New() const final {
    return CreateMaybeMessage<ResponseCheckTx>(nullptr);
  }

  ResponseCheckTx* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseCheckTx>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ResponseCheckTx& from);
  void MergeFrom(const ResponseCheckTx& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResponseCheckTx* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .suil.tmsp.types.KVPair tags = 7;
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 7;
  ::suil::tmsp::types::KVPair* mutable_tags(int index);
  ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::KVPair >*
      mutable_tags();
  const ::suil::tmsp::types::KVPair& tags(int index) const;
  ::suil::tmsp::types::KVPair* add_tags();
  const ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::KVPair >&
      tags() const;

  // bytes data = 2;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // string log = 3;
  void clear_log();
  static const int kLogFieldNumber = 3;
  const ::std::string& log() const;
  void set_log(const ::std::string& value);
  #if LANG_CXX11
  void set_log(::std::string&& value);
  #endif
  void set_log(const char* value);
  void set_log(const char* value, size_t size);
  ::std::string* mutable_log();
  ::std::string* release_log();
  void set_allocated_log(::std::string* log);

  // string info = 4;
  void clear_info();
  static const int kInfoFieldNumber = 4;
  const ::std::string& info() const;
  void set_info(const ::std::string& value);
  #if LANG_CXX11
  void set_info(::std::string&& value);
  #endif
  void set_info(const char* value);
  void set_info(const char* value, size_t size);
  ::std::string* mutable_info();
  ::std::string* release_info();
  void set_allocated_info(::std::string* info);

  // string codespace = 8;
  void clear_codespace();
  static const int kCodespaceFieldNumber = 8;
  const ::std::string& codespace() const;
  void set_codespace(const ::std::string& value);
  #if LANG_CXX11
  void set_codespace(::std::string&& value);
  #endif
  void set_codespace(const char* value);
  void set_codespace(const char* value, size_t size);
  ::std::string* mutable_codespace();
  ::std::string* release_codespace();
  void set_allocated_codespace(::std::string* codespace);

  // int64 gas_wanted = 5;
  void clear_gas_wanted();
  static const int kGasWantedFieldNumber = 5;
  ::google::protobuf::int64 gas_wanted() const;
  void set_gas_wanted(::google::protobuf::int64 value);

  // int64 gas_used = 6;
  void clear_gas_used();
  static const int kGasUsedFieldNumber = 6;
  ::google::protobuf::int64 gas_used() const;
  void set_gas_used(::google::protobuf::int64 value);

  // uint32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::uint32 code() const;
  void set_code(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:suil.tmsp.types.ResponseCheckTx)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::KVPair > tags_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::internal::ArenaStringPtr log_;
  ::google::protobuf::internal::ArenaStringPtr info_;
  ::google::protobuf::internal::ArenaStringPtr codespace_;
  ::google::protobuf::int64 gas_wanted_;
  ::google::protobuf::int64 gas_used_;
  ::google::protobuf::uint32 code_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class ResponseDeliverTx final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:suil.tmsp.types.ResponseDeliverTx) */ {
 public:
  ResponseDeliverTx();
  virtual ~ResponseDeliverTx();

  ResponseDeliverTx(const ResponseDeliverTx& from);

  inline ResponseDeliverTx& operator=(const ResponseDeliverTx& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseDeliverTx(ResponseDeliverTx&& from) noexcept
    : ResponseDeliverTx() {
    *this = ::std::move(from);
  }

  inline ResponseDeliverTx& operator=(ResponseDeliverTx&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ResponseDeliverTx& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseDeliverTx* internal_default_instance() {
    return reinterpret_cast<const ResponseDeliverTx*>(
               &_ResponseDeliverTx_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(ResponseDeliverTx* other);
  friend void swap(ResponseDeliverTx& a, ResponseDeliverTx& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseDeliverTx* New() const final {
    return CreateMaybeMessage<ResponseDeliverTx>(nullptr);
  }

  ResponseDeliverTx* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseDeliverTx>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ResponseDeliverTx& from);
  void MergeFrom(const ResponseDeliverTx& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResponseDeliverTx* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .suil.tmsp.types.KVPair tags = 7;
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 7;
  ::suil::tmsp::types::KVPair* mutable_tags(int index);
  ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::KVPair >*
      mutable_tags();
  const ::suil::tmsp::types::KVPair& tags(int index) const;
  ::suil::tmsp::types::KVPair* add_tags();
  const ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::KVPair >&
      tags() const;

  // bytes data = 2;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // string log = 3;
  void clear_log();
  static const int kLogFieldNumber = 3;
  const ::std::string& log() const;
  void set_log(const ::std::string& value);
  #if LANG_CXX11
  void set_log(::std::string&& value);
  #endif
  void set_log(const char* value);
  void set_log(const char* value, size_t size);
  ::std::string* mutable_log();
  ::std::string* release_log();
  void set_allocated_log(::std::string* log);

  // string info = 4;
  void clear_info();
  static const int kInfoFieldNumber = 4;
  const ::std::string& info() const;
  void set_info(const ::std::string& value);
  #if LANG_CXX11
  void set_info(::std::string&& value);
  #endif
  void set_info(const char* value);
  void set_info(const char* value, size_t size);
  ::std::string* mutable_info();
  ::std::string* release_info();
  void set_allocated_info(::std::string* info);

  // string codespace = 8;
  void clear_codespace();
  static const int kCodespaceFieldNumber = 8;
  const ::std::string& codespace() const;
  void set_codespace(const ::std::string& value);
  #if LANG_CXX11
  void set_codespace(::std::string&& value);
  #endif
  void set_codespace(const char* value);
  void set_codespace(const char* value, size_t size);
  ::std::string* mutable_codespace();
  ::std::string* release_codespace();
  void set_allocated_codespace(::std::string* codespace);

  // int64 gas_wanted = 5;
  void clear_gas_wanted();
  static const int kGasWantedFieldNumber = 5;
  ::google::protobuf::int64 gas_wanted() const;
  void set_gas_wanted(::google::protobuf::int64 value);

  // int64 gas_used = 6;
  void clear_gas_used();
  static const int kGasUsedFieldNumber = 6;
  ::google::protobuf::int64 gas_used() const;
  void set_gas_used(::google::protobuf::int64 value);

  // uint32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::uint32 code() const;
  void set_code(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:suil.tmsp.types.ResponseDeliverTx)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::KVPair > tags_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::internal::ArenaStringPtr log_;
  ::google::protobuf::internal::ArenaStringPtr info_;
  ::google::protobuf::internal::ArenaStringPtr codespace_;
  ::google::protobuf::int64 gas_wanted_;
  ::google::protobuf::int64 gas_used_;
  ::google::protobuf::uint32 code_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class ResponseEndBlock final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:suil.tmsp.types.ResponseEndBlock) */ {
 public:
  ResponseEndBlock();
  virtual ~ResponseEndBlock();

  ResponseEndBlock(const ResponseEndBlock& from);

  inline ResponseEndBlock& operator=(const ResponseEndBlock& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseEndBlock(ResponseEndBlock&& from) noexcept
    : ResponseEndBlock() {
    *this = ::std::move(from);
  }

  inline ResponseEndBlock& operator=(ResponseEndBlock&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ResponseEndBlock& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseEndBlock* internal_default_instance() {
    return reinterpret_cast<const ResponseEndBlock*>(
               &_ResponseEndBlock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(ResponseEndBlock* other);
  friend void swap(ResponseEndBlock& a, ResponseEndBlock& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseEndBlock* New() const final {
    return CreateMaybeMessage<ResponseEndBlock>(nullptr);
  }

  ResponseEndBlock* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseEndBlock>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ResponseEndBlock& from);
  void MergeFrom(const ResponseEndBlock& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResponseEndBlock* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .suil.tmsp.types.ValidatorUpdate validator_updates = 1;
  int validator_updates_size() const;
  void clear_validator_updates();
  static const int kValidatorUpdatesFieldNumber = 1;
  ::suil::tmsp::types::ValidatorUpdate* mutable_validator_updates(int index);
  ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::ValidatorUpdate >*
      mutable_validator_updates();
  const ::suil::tmsp::types::ValidatorUpdate& validator_updates(int index) const;
  ::suil::tmsp::types::ValidatorUpdate* add_validator_updates();
  const ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::ValidatorUpdate >&
      validator_updates() const;

  // repeated .suil.tmsp.types.KVPair tags = 3;
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 3;
  ::suil::tmsp::types::KVPair* mutable_tags(int index);
  ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::KVPair >*
      mutable_tags();
  const ::suil::tmsp::types::KVPair& tags(int index) const;
  ::suil::tmsp::types::KVPair* add_tags();
  const ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::KVPair >&
      tags() const;

  // .suil.tmsp.types.ConsensusParams consensus_param_updates = 2;
  bool has_consensus_param_updates() const;
  void clear_consensus_param_updates();
  static const int kConsensusParamUpdatesFieldNumber = 2;
  const ::suil::tmsp::types::ConsensusParams& consensus_param_updates() const;
  ::suil::tmsp::types::ConsensusParams* release_consensus_param_updates();
  ::suil::tmsp::types::ConsensusParams* mutable_consensus_param_updates();
  void set_allocated_consensus_param_updates(::suil::tmsp::types::ConsensusParams* consensus_param_updates);

  // @@protoc_insertion_point(class_scope:suil.tmsp.types.ResponseEndBlock)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::ValidatorUpdate > validator_updates_;
  ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::KVPair > tags_;
  ::suil::tmsp::types::ConsensusParams* consensus_param_updates_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class ResponseCommit final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:suil.tmsp.types.ResponseCommit) */ {
 public:
  ResponseCommit();
  virtual ~ResponseCommit();

  ResponseCommit(const ResponseCommit& from);

  inline ResponseCommit& operator=(const ResponseCommit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseCommit(ResponseCommit&& from) noexcept
    : ResponseCommit() {
    *this = ::std::move(from);
  }

  inline ResponseCommit& operator=(ResponseCommit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ResponseCommit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseCommit* internal_default_instance() {
    return reinterpret_cast<const ResponseCommit*>(
               &_ResponseCommit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(ResponseCommit* other);
  friend void swap(ResponseCommit& a, ResponseCommit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseCommit* New() const final {
    return CreateMaybeMessage<ResponseCommit>(nullptr);
  }

  ResponseCommit* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseCommit>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ResponseCommit& from);
  void MergeFrom(const ResponseCommit& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResponseCommit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes data = 2;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:suil.tmsp.types.ResponseCommit)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class ConsensusParams final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:suil.tmsp.types.ConsensusParams) */ {
 public:
  ConsensusParams();
  virtual ~ConsensusParams();

  ConsensusParams(const ConsensusParams& from);

  inline ConsensusParams& operator=(const ConsensusParams& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConsensusParams(ConsensusParams&& from) noexcept
    : ConsensusParams() {
    *this = ::std::move(from);
  }

  inline ConsensusParams& operator=(ConsensusParams&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ConsensusParams& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConsensusParams* internal_default_instance() {
    return reinterpret_cast<const ConsensusParams*>(
               &_ConsensusParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void Swap(ConsensusParams* other);
  friend void swap(ConsensusParams& a, ConsensusParams& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConsensusParams* New() const final {
    return CreateMaybeMessage<ConsensusParams>(nullptr);
  }

  ConsensusParams* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConsensusParams>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ConsensusParams& from);
  void MergeFrom(const ConsensusParams& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConsensusParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .suil.tmsp.types.BlockSizeParams block_size = 1;
  bool has_block_size() const;
  void clear_block_size();
  static const int kBlockSizeFieldNumber = 1;
  const ::suil::tmsp::types::BlockSizeParams& block_size() const;
  ::suil::tmsp::types::BlockSizeParams* release_block_size();
  ::suil::tmsp::types::BlockSizeParams* mutable_block_size();
  void set_allocated_block_size(::suil::tmsp::types::BlockSizeParams* block_size);

  // .suil.tmsp.types.EvidenceParams evidence = 2;
  bool has_evidence() const;
  void clear_evidence();
  static const int kEvidenceFieldNumber = 2;
  const ::suil::tmsp::types::EvidenceParams& evidence() const;
  ::suil::tmsp::types::EvidenceParams* release_evidence();
  ::suil::tmsp::types::EvidenceParams* mutable_evidence();
  void set_allocated_evidence(::suil::tmsp::types::EvidenceParams* evidence);

  // .suil.tmsp.types.ValidatorParams validator = 3;
  bool has_validator() const;
  void clear_validator();
  static const int kValidatorFieldNumber = 3;
  const ::suil::tmsp::types::ValidatorParams& validator() const;
  ::suil::tmsp::types::ValidatorParams* release_validator();
  ::suil::tmsp::types::ValidatorParams* mutable_validator();
  void set_allocated_validator(::suil::tmsp::types::ValidatorParams* validator);

  // @@protoc_insertion_point(class_scope:suil.tmsp.types.ConsensusParams)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::suil::tmsp::types::BlockSizeParams* block_size_;
  ::suil::tmsp::types::EvidenceParams* evidence_;
  ::suil::tmsp::types::ValidatorParams* validator_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class BlockSizeParams final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:suil.tmsp.types.BlockSizeParams) */ {
 public:
  BlockSizeParams();
  virtual ~BlockSizeParams();

  BlockSizeParams(const BlockSizeParams& from);

  inline BlockSizeParams& operator=(const BlockSizeParams& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BlockSizeParams(BlockSizeParams&& from) noexcept
    : BlockSizeParams() {
    *this = ::std::move(from);
  }

  inline BlockSizeParams& operator=(BlockSizeParams&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const BlockSizeParams& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlockSizeParams* internal_default_instance() {
    return reinterpret_cast<const BlockSizeParams*>(
               &_BlockSizeParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  void Swap(BlockSizeParams* other);
  friend void swap(BlockSizeParams& a, BlockSizeParams& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BlockSizeParams* New() const final {
    return CreateMaybeMessage<BlockSizeParams>(nullptr);
  }

  BlockSizeParams* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BlockSizeParams>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const BlockSizeParams& from);
  void MergeFrom(const BlockSizeParams& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BlockSizeParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 max_bytes = 1;
  void clear_max_bytes();
  static const int kMaxBytesFieldNumber = 1;
  ::google::protobuf::int64 max_bytes() const;
  void set_max_bytes(::google::protobuf::int64 value);

  // int64 max_gas = 2;
  void clear_max_gas();
  static const int kMaxGasFieldNumber = 2;
  ::google::protobuf::int64 max_gas() const;
  void set_max_gas(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:suil.tmsp.types.BlockSizeParams)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::int64 max_bytes_;
  ::google::protobuf::int64 max_gas_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class EvidenceParams final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:suil.tmsp.types.EvidenceParams) */ {
 public:
  EvidenceParams();
  virtual ~EvidenceParams();

  EvidenceParams(const EvidenceParams& from);

  inline EvidenceParams& operator=(const EvidenceParams& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EvidenceParams(EvidenceParams&& from) noexcept
    : EvidenceParams() {
    *this = ::std::move(from);
  }

  inline EvidenceParams& operator=(EvidenceParams&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const EvidenceParams& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EvidenceParams* internal_default_instance() {
    return reinterpret_cast<const EvidenceParams*>(
               &_EvidenceParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  void Swap(EvidenceParams* other);
  friend void swap(EvidenceParams& a, EvidenceParams& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EvidenceParams* New() const final {
    return CreateMaybeMessage<EvidenceParams>(nullptr);
  }

  EvidenceParams* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EvidenceParams>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const EvidenceParams& from);
  void MergeFrom(const EvidenceParams& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EvidenceParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 max_age = 1;
  void clear_max_age();
  static const int kMaxAgeFieldNumber = 1;
  ::google::protobuf::int64 max_age() const;
  void set_max_age(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:suil.tmsp.types.EvidenceParams)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::int64 max_age_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class ValidatorParams final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:suil.tmsp.types.ValidatorParams) */ {
 public:
  ValidatorParams();
  virtual ~ValidatorParams();

  ValidatorParams(const ValidatorParams& from);

  inline ValidatorParams& operator=(const ValidatorParams& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ValidatorParams(ValidatorParams&& from) noexcept
    : ValidatorParams() {
    *this = ::std::move(from);
  }

  inline ValidatorParams& operator=(ValidatorParams&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ValidatorParams& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ValidatorParams* internal_default_instance() {
    return reinterpret_cast<const ValidatorParams*>(
               &_ValidatorParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  void Swap(ValidatorParams* other);
  friend void swap(ValidatorParams& a, ValidatorParams& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ValidatorParams* New() const final {
    return CreateMaybeMessage<ValidatorParams>(nullptr);
  }

  ValidatorParams* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ValidatorParams>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ValidatorParams& from);
  void MergeFrom(const ValidatorParams& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ValidatorParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string pub_key_types = 1;
  int pub_key_types_size() const;
  void clear_pub_key_types();
  static const int kPubKeyTypesFieldNumber = 1;
  const ::std::string& pub_key_types(int index) const;
  ::std::string* mutable_pub_key_types(int index);
  void set_pub_key_types(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_pub_key_types(int index, ::std::string&& value);
  #endif
  void set_pub_key_types(int index, const char* value);
  void set_pub_key_types(int index, const char* value, size_t size);
  ::std::string* add_pub_key_types();
  void add_pub_key_types(const ::std::string& value);
  #if LANG_CXX11
  void add_pub_key_types(::std::string&& value);
  #endif
  void add_pub_key_types(const char* value);
  void add_pub_key_types(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& pub_key_types() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_pub_key_types();

  // @@protoc_insertion_point(class_scope:suil.tmsp.types.ValidatorParams)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField<::std::string> pub_key_types_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class LastCommitInfo final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:suil.tmsp.types.LastCommitInfo) */ {
 public:
  LastCommitInfo();
  virtual ~LastCommitInfo();

  LastCommitInfo(const LastCommitInfo& from);

  inline LastCommitInfo& operator=(const LastCommitInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LastCommitInfo(LastCommitInfo&& from) noexcept
    : LastCommitInfo() {
    *this = ::std::move(from);
  }

  inline LastCommitInfo& operator=(LastCommitInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const LastCommitInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LastCommitInfo* internal_default_instance() {
    return reinterpret_cast<const LastCommitInfo*>(
               &_LastCommitInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  void Swap(LastCommitInfo* other);
  friend void swap(LastCommitInfo& a, LastCommitInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LastCommitInfo* New() const final {
    return CreateMaybeMessage<LastCommitInfo>(nullptr);
  }

  LastCommitInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LastCommitInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const LastCommitInfo& from);
  void MergeFrom(const LastCommitInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LastCommitInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .suil.tmsp.types.VoteInfo votes = 2;
  int votes_size() const;
  void clear_votes();
  static const int kVotesFieldNumber = 2;
  ::suil::tmsp::types::VoteInfo* mutable_votes(int index);
  ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::VoteInfo >*
      mutable_votes();
  const ::suil::tmsp::types::VoteInfo& votes(int index) const;
  ::suil::tmsp::types::VoteInfo* add_votes();
  const ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::VoteInfo >&
      votes() const;

  // int32 round = 1;
  void clear_round();
  static const int kRoundFieldNumber = 1;
  ::google::protobuf::int32 round() const;
  void set_round(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:suil.tmsp.types.LastCommitInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::VoteInfo > votes_;
  ::google::protobuf::int32 round_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class Header final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:suil.tmsp.types.Header) */ {
 public:
  Header();
  virtual ~Header();

  Header(const Header& from);

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Header(Header&& from) noexcept
    : Header() {
    *this = ::std::move(from);
  }

  inline Header& operator=(Header&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Header& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Header* internal_default_instance() {
    return reinterpret_cast<const Header*>(
               &_Header_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  void Swap(Header* other);
  friend void swap(Header& a, Header& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Header* New() const final {
    return CreateMaybeMessage<Header>(nullptr);
  }

  Header* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Header>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Header& from);
  void MergeFrom(const Header& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Header* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string chain_id = 2;
  void clear_chain_id();
  static const int kChainIdFieldNumber = 2;
  const ::std::string& chain_id() const;
  void set_chain_id(const ::std::string& value);
  #if LANG_CXX11
  void set_chain_id(::std::string&& value);
  #endif
  void set_chain_id(const char* value);
  void set_chain_id(const char* value, size_t size);
  ::std::string* mutable_chain_id();
  ::std::string* release_chain_id();
  void set_allocated_chain_id(::std::string* chain_id);

  // bytes last_commit_hash = 8;
  void clear_last_commit_hash();
  static const int kLastCommitHashFieldNumber = 8;
  const ::std::string& last_commit_hash() const;
  void set_last_commit_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_last_commit_hash(::std::string&& value);
  #endif
  void set_last_commit_hash(const char* value);
  void set_last_commit_hash(const void* value, size_t size);
  ::std::string* mutable_last_commit_hash();
  ::std::string* release_last_commit_hash();
  void set_allocated_last_commit_hash(::std::string* last_commit_hash);

  // bytes data_hash = 9;
  void clear_data_hash();
  static const int kDataHashFieldNumber = 9;
  const ::std::string& data_hash() const;
  void set_data_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_data_hash(::std::string&& value);
  #endif
  void set_data_hash(const char* value);
  void set_data_hash(const void* value, size_t size);
  ::std::string* mutable_data_hash();
  ::std::string* release_data_hash();
  void set_allocated_data_hash(::std::string* data_hash);

  // bytes validators_hash = 10;
  void clear_validators_hash();
  static const int kValidatorsHashFieldNumber = 10;
  const ::std::string& validators_hash() const;
  void set_validators_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_validators_hash(::std::string&& value);
  #endif
  void set_validators_hash(const char* value);
  void set_validators_hash(const void* value, size_t size);
  ::std::string* mutable_validators_hash();
  ::std::string* release_validators_hash();
  void set_allocated_validators_hash(::std::string* validators_hash);

  // bytes next_validators_hash = 11;
  void clear_next_validators_hash();
  static const int kNextValidatorsHashFieldNumber = 11;
  const ::std::string& next_validators_hash() const;
  void set_next_validators_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_next_validators_hash(::std::string&& value);
  #endif
  void set_next_validators_hash(const char* value);
  void set_next_validators_hash(const void* value, size_t size);
  ::std::string* mutable_next_validators_hash();
  ::std::string* release_next_validators_hash();
  void set_allocated_next_validators_hash(::std::string* next_validators_hash);

  // bytes consensus_hash = 12;
  void clear_consensus_hash();
  static const int kConsensusHashFieldNumber = 12;
  const ::std::string& consensus_hash() const;
  void set_consensus_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_consensus_hash(::std::string&& value);
  #endif
  void set_consensus_hash(const char* value);
  void set_consensus_hash(const void* value, size_t size);
  ::std::string* mutable_consensus_hash();
  ::std::string* release_consensus_hash();
  void set_allocated_consensus_hash(::std::string* consensus_hash);

  // bytes app_hash = 13;
  void clear_app_hash();
  static const int kAppHashFieldNumber = 13;
  const ::std::string& app_hash() const;
  void set_app_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_app_hash(::std::string&& value);
  #endif
  void set_app_hash(const char* value);
  void set_app_hash(const void* value, size_t size);
  ::std::string* mutable_app_hash();
  ::std::string* release_app_hash();
  void set_allocated_app_hash(::std::string* app_hash);

  // bytes last_results_hash = 14;
  void clear_last_results_hash();
  static const int kLastResultsHashFieldNumber = 14;
  const ::std::string& last_results_hash() const;
  void set_last_results_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_last_results_hash(::std::string&& value);
  #endif
  void set_last_results_hash(const char* value);
  void set_last_results_hash(const void* value, size_t size);
  ::std::string* mutable_last_results_hash();
  ::std::string* release_last_results_hash();
  void set_allocated_last_results_hash(::std::string* last_results_hash);

  // bytes evidence_hash = 15;
  void clear_evidence_hash();
  static const int kEvidenceHashFieldNumber = 15;
  const ::std::string& evidence_hash() const;
  void set_evidence_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_evidence_hash(::std::string&& value);
  #endif
  void set_evidence_hash(const char* value);
  void set_evidence_hash(const void* value, size_t size);
  ::std::string* mutable_evidence_hash();
  ::std::string* release_evidence_hash();
  void set_allocated_evidence_hash(::std::string* evidence_hash);

  // bytes proposer_address = 16;
  void clear_proposer_address();
  static const int kProposerAddressFieldNumber = 16;
  const ::std::string& proposer_address() const;
  void set_proposer_address(const ::std::string& value);
  #if LANG_CXX11
  void set_proposer_address(::std::string&& value);
  #endif
  void set_proposer_address(const char* value);
  void set_proposer_address(const void* value, size_t size);
  ::std::string* mutable_proposer_address();
  ::std::string* release_proposer_address();
  void set_allocated_proposer_address(::std::string* proposer_address);

  // .suil.tmsp.types.Version version = 1;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  const ::suil::tmsp::types::Version& version() const;
  ::suil::tmsp::types::Version* release_version();
  ::suil::tmsp::types::Version* mutable_version();
  void set_allocated_version(::suil::tmsp::types::Version* version);

  // .suil.tmsp.types.Timestamp time = 4;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 4;
  const ::suil::tmsp::types::Timestamp& time() const;
  ::suil::tmsp::types::Timestamp* release_time();
  ::suil::tmsp::types::Timestamp* mutable_time();
  void set_allocated_time(::suil::tmsp::types::Timestamp* time);

  // .suil.tmsp.types.BlockID last_block_id = 7;
  bool has_last_block_id() const;
  void clear_last_block_id();
  static const int kLastBlockIdFieldNumber = 7;
  const ::suil::tmsp::types::BlockID& last_block_id() const;
  ::suil::tmsp::types::BlockID* release_last_block_id();
  ::suil::tmsp::types::BlockID* mutable_last_block_id();
  void set_allocated_last_block_id(::suil::tmsp::types::BlockID* last_block_id);

  // int64 height = 3;
  void clear_height();
  static const int kHeightFieldNumber = 3;
  ::google::protobuf::int64 height() const;
  void set_height(::google::protobuf::int64 value);

  // int64 num_txs = 5;
  void clear_num_txs();
  static const int kNumTxsFieldNumber = 5;
  ::google::protobuf::int64 num_txs() const;
  void set_num_txs(::google::protobuf::int64 value);

  // int64 total_txs = 6;
  void clear_total_txs();
  static const int kTotalTxsFieldNumber = 6;
  ::google::protobuf::int64 total_txs() const;
  void set_total_txs(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:suil.tmsp.types.Header)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr chain_id_;
  ::google::protobuf::internal::ArenaStringPtr last_commit_hash_;
  ::google::protobuf::internal::ArenaStringPtr data_hash_;
  ::google::protobuf::internal::ArenaStringPtr validators_hash_;
  ::google::protobuf::internal::ArenaStringPtr next_validators_hash_;
  ::google::protobuf::internal::ArenaStringPtr consensus_hash_;
  ::google::protobuf::internal::ArenaStringPtr app_hash_;
  ::google::protobuf::internal::ArenaStringPtr last_results_hash_;
  ::google::protobuf::internal::ArenaStringPtr evidence_hash_;
  ::google::protobuf::internal::ArenaStringPtr proposer_address_;
  ::suil::tmsp::types::Version* version_;
  ::suil::tmsp::types::Timestamp* time_;
  ::suil::tmsp::types::BlockID* last_block_id_;
  ::google::protobuf::int64 height_;
  ::google::protobuf::int64 num_txs_;
  ::google::protobuf::int64 total_txs_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class Version final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:suil.tmsp.types.Version) */ {
 public:
  Version();
  virtual ~Version();

  Version(const Version& from);

  inline Version& operator=(const Version& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Version(Version&& from) noexcept
    : Version() {
    *this = ::std::move(from);
  }

  inline Version& operator=(Version&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Version& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Version* internal_default_instance() {
    return reinterpret_cast<const Version*>(
               &_Version_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  void Swap(Version* other);
  friend void swap(Version& a, Version& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Version* New() const final {
    return CreateMaybeMessage<Version>(nullptr);
  }

  Version* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Version>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Version& from);
  void MergeFrom(const Version& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Version* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 Block = 1;
  void clear_block();
  static const int kBlockFieldNumber = 1;
  ::google::protobuf::uint64 block() const;
  void set_block(::google::protobuf::uint64 value);

  // uint64 App = 2;
  void clear_app();
  static const int kAppFieldNumber = 2;
  ::google::protobuf::uint64 app() const;
  void set_app(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:suil.tmsp.types.Version)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::uint64 block_;
  ::google::protobuf::uint64 app_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class BlockID final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:suil.tmsp.types.BlockID) */ {
 public:
  BlockID();
  virtual ~BlockID();

  BlockID(const BlockID& from);

  inline BlockID& operator=(const BlockID& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BlockID(BlockID&& from) noexcept
    : BlockID() {
    *this = ::std::move(from);
  }

  inline BlockID& operator=(BlockID&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const BlockID& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlockID* internal_default_instance() {
    return reinterpret_cast<const BlockID*>(
               &_BlockID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  void Swap(BlockID* other);
  friend void swap(BlockID& a, BlockID& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BlockID* New() const final {
    return CreateMaybeMessage<BlockID>(nullptr);
  }

  BlockID* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BlockID>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const BlockID& from);
  void MergeFrom(const BlockID& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BlockID* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes hash = 1;
  void clear_hash();
  static const int kHashFieldNumber = 1;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // .suil.tmsp.types.PartSetHeader parts_header = 2;
  bool has_parts_header() const;
  void clear_parts_header();
  static const int kPartsHeaderFieldNumber = 2;
  const ::suil::tmsp::types::PartSetHeader& parts_header() const;
  ::suil::tmsp::types::PartSetHeader* release_parts_header();
  ::suil::tmsp::types::PartSetHeader* mutable_parts_header();
  void set_allocated_parts_header(::suil::tmsp::types::PartSetHeader* parts_header);

  // @@protoc_insertion_point(class_scope:suil.tmsp.types.BlockID)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::suil::tmsp::types::PartSetHeader* parts_header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class PartSetHeader final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:suil.tmsp.types.PartSetHeader) */ {
 public:
  PartSetHeader();
  virtual ~PartSetHeader();

  PartSetHeader(const PartSetHeader& from);

  inline PartSetHeader& operator=(const PartSetHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PartSetHeader(PartSetHeader&& from) noexcept
    : PartSetHeader() {
    *this = ::std::move(from);
  }

  inline PartSetHeader& operator=(PartSetHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const PartSetHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PartSetHeader* internal_default_instance() {
    return reinterpret_cast<const PartSetHeader*>(
               &_PartSetHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  void Swap(PartSetHeader* other);
  friend void swap(PartSetHeader& a, PartSetHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PartSetHeader* New() const final {
    return CreateMaybeMessage<PartSetHeader>(nullptr);
  }

  PartSetHeader* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PartSetHeader>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const PartSetHeader& from);
  void MergeFrom(const PartSetHeader& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PartSetHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes hash = 2;
  void clear_hash();
  static const int kHashFieldNumber = 2;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // int32 total = 1;
  void clear_total();
  static const int kTotalFieldNumber = 1;
  ::google::protobuf::int32 total() const;
  void set_total(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:suil.tmsp.types.PartSetHeader)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::int32 total_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class Validator final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:suil.tmsp.types.Validator) */ {
 public:
  Validator();
  virtual ~Validator();

  Validator(const Validator& from);

  inline Validator& operator=(const Validator& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Validator(Validator&& from) noexcept
    : Validator() {
    *this = ::std::move(from);
  }

  inline Validator& operator=(Validator&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Validator& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Validator* internal_default_instance() {
    return reinterpret_cast<const Validator*>(
               &_Validator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  void Swap(Validator* other);
  friend void swap(Validator& a, Validator& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Validator* New() const final {
    return CreateMaybeMessage<Validator>(nullptr);
  }

  Validator* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Validator>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Validator& from);
  void MergeFrom(const Validator& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Validator* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes address = 1;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const void* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // int64 power = 3;
  void clear_power();
  static const int kPowerFieldNumber = 3;
  ::google::protobuf::int64 power() const;
  void set_power(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:suil.tmsp.types.Validator)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::int64 power_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class ValidatorUpdate final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:suil.tmsp.types.ValidatorUpdate) */ {
 public:
  ValidatorUpdate();
  virtual ~ValidatorUpdate();

  ValidatorUpdate(const ValidatorUpdate& from);

  inline ValidatorUpdate& operator=(const ValidatorUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ValidatorUpdate(ValidatorUpdate&& from) noexcept
    : ValidatorUpdate() {
    *this = ::std::move(from);
  }

  inline ValidatorUpdate& operator=(ValidatorUpdate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ValidatorUpdate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ValidatorUpdate* internal_default_instance() {
    return reinterpret_cast<const ValidatorUpdate*>(
               &_ValidatorUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  void Swap(ValidatorUpdate* other);
  friend void swap(ValidatorUpdate& a, ValidatorUpdate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ValidatorUpdate* New() const final {
    return CreateMaybeMessage<ValidatorUpdate>(nullptr);
  }

  ValidatorUpdate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ValidatorUpdate>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ValidatorUpdate& from);
  void MergeFrom(const ValidatorUpdate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ValidatorUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .suil.tmsp.types.PubKey pub_key = 1;
  bool has_pub_key() const;
  void clear_pub_key();
  static const int kPubKeyFieldNumber = 1;
  const ::suil::tmsp::types::PubKey& pub_key() const;
  ::suil::tmsp::types::PubKey* release_pub_key();
  ::suil::tmsp::types::PubKey* mutable_pub_key();
  void set_allocated_pub_key(::suil::tmsp::types::PubKey* pub_key);

  // int64 power = 2;
  void clear_power();
  static const int kPowerFieldNumber = 2;
  ::google::protobuf::int64 power() const;
  void set_power(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:suil.tmsp.types.ValidatorUpdate)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::suil::tmsp::types::PubKey* pub_key_;
  ::google::protobuf::int64 power_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class VoteInfo final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:suil.tmsp.types.VoteInfo) */ {
 public:
  VoteInfo();
  virtual ~VoteInfo();

  VoteInfo(const VoteInfo& from);

  inline VoteInfo& operator=(const VoteInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VoteInfo(VoteInfo&& from) noexcept
    : VoteInfo() {
    *this = ::std::move(from);
  }

  inline VoteInfo& operator=(VoteInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const VoteInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VoteInfo* internal_default_instance() {
    return reinterpret_cast<const VoteInfo*>(
               &_VoteInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  void Swap(VoteInfo* other);
  friend void swap(VoteInfo& a, VoteInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VoteInfo* New() const final {
    return CreateMaybeMessage<VoteInfo>(nullptr);
  }

  VoteInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VoteInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const VoteInfo& from);
  void MergeFrom(const VoteInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VoteInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .suil.tmsp.types.Validator validator = 1;
  bool has_validator() const;
  void clear_validator();
  static const int kValidatorFieldNumber = 1;
  const ::suil::tmsp::types::Validator& validator() const;
  ::suil::tmsp::types::Validator* release_validator();
  ::suil::tmsp::types::Validator* mutable_validator();
  void set_allocated_validator(::suil::tmsp::types::Validator* validator);

  // bool signed_last_block = 2;
  void clear_signed_last_block();
  static const int kSignedLastBlockFieldNumber = 2;
  bool signed_last_block() const;
  void set_signed_last_block(bool value);

  // @@protoc_insertion_point(class_scope:suil.tmsp.types.VoteInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::suil::tmsp::types::Validator* validator_;
  bool signed_last_block_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class PubKey final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:suil.tmsp.types.PubKey) */ {
 public:
  PubKey();
  virtual ~PubKey();

  PubKey(const PubKey& from);

  inline PubKey& operator=(const PubKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PubKey(PubKey&& from) noexcept
    : PubKey() {
    *this = ::std::move(from);
  }

  inline PubKey& operator=(PubKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const PubKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PubKey* internal_default_instance() {
    return reinterpret_cast<const PubKey*>(
               &_PubKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  void Swap(PubKey* other);
  friend void swap(PubKey& a, PubKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PubKey* New() const final {
    return CreateMaybeMessage<PubKey>(nullptr);
  }

  PubKey* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PubKey>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const PubKey& from);
  void MergeFrom(const PubKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PubKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // bytes data = 2;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:suil.tmsp.types.PubKey)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class Evidence final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:suil.tmsp.types.Evidence) */ {
 public:
  Evidence();
  virtual ~Evidence();

  Evidence(const Evidence& from);

  inline Evidence& operator=(const Evidence& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Evidence(Evidence&& from) noexcept
    : Evidence() {
    *this = ::std::move(from);
  }

  inline Evidence& operator=(Evidence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Evidence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Evidence* internal_default_instance() {
    return reinterpret_cast<const Evidence*>(
               &_Evidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  void Swap(Evidence* other);
  friend void swap(Evidence& a, Evidence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Evidence* New() const final {
    return CreateMaybeMessage<Evidence>(nullptr);
  }

  Evidence* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Evidence>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Evidence& from);
  void MergeFrom(const Evidence& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Evidence* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // .suil.tmsp.types.Validator validator = 2;
  bool has_validator() const;
  void clear_validator();
  static const int kValidatorFieldNumber = 2;
  const ::suil::tmsp::types::Validator& validator() const;
  ::suil::tmsp::types::Validator* release_validator();
  ::suil::tmsp::types::Validator* mutable_validator();
  void set_allocated_validator(::suil::tmsp::types::Validator* validator);

  // .suil.tmsp.types.Timestamp time = 4;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 4;
  const ::suil::tmsp::types::Timestamp& time() const;
  ::suil::tmsp::types::Timestamp* release_time();
  ::suil::tmsp::types::Timestamp* mutable_time();
  void set_allocated_time(::suil::tmsp::types::Timestamp* time);

  // int64 height = 3;
  void clear_height();
  static const int kHeightFieldNumber = 3;
  ::google::protobuf::int64 height() const;
  void set_height(::google::protobuf::int64 value);

  // int64 total_voting_power = 5;
  void clear_total_voting_power();
  static const int kTotalVotingPowerFieldNumber = 5;
  ::google::protobuf::int64 total_voting_power() const;
  void set_total_voting_power(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:suil.tmsp.types.Evidence)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::suil::tmsp::types::Validator* validator_;
  ::suil::tmsp::types::Timestamp* time_;
  ::google::protobuf::int64 height_;
  ::google::protobuf::int64 total_voting_power_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_types_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ProofOp

// string type = 1;
inline void ProofOp::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProofOp::type() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ProofOp.type)
  return type_.GetNoArena();
}
inline void ProofOp::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.ProofOp.type)
}
#if LANG_CXX11
inline void ProofOp::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.ProofOp.type)
}
#endif
inline void ProofOp::set_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.ProofOp.type)
}
inline void ProofOp::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.ProofOp.type)
}
inline ::std::string* ProofOp::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.ProofOp.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProofOp::release_type() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.ProofOp.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProofOp::set_allocated_type(::std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.ProofOp.type)
}

// bytes key = 2;
inline void ProofOp::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProofOp::key() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ProofOp.key)
  return key_.GetNoArena();
}
inline void ProofOp::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.ProofOp.key)
}
#if LANG_CXX11
inline void ProofOp::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.ProofOp.key)
}
#endif
inline void ProofOp::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.ProofOp.key)
}
inline void ProofOp::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.ProofOp.key)
}
inline ::std::string* ProofOp::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.ProofOp.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProofOp::release_key() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.ProofOp.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProofOp::set_allocated_key(::std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.ProofOp.key)
}

// bytes data = 3;
inline void ProofOp::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProofOp::data() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ProofOp.data)
  return data_.GetNoArena();
}
inline void ProofOp::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.ProofOp.data)
}
#if LANG_CXX11
inline void ProofOp::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.ProofOp.data)
}
#endif
inline void ProofOp::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.ProofOp.data)
}
inline void ProofOp::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.ProofOp.data)
}
inline ::std::string* ProofOp::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.ProofOp.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProofOp::release_data() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.ProofOp.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProofOp::set_allocated_data(::std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.ProofOp.data)
}

// -------------------------------------------------------------------

// Proof

// repeated .suil.tmsp.types.ProofOp ops = 1;
inline int Proof::ops_size() const {
  return ops_.size();
}
inline void Proof::clear_ops() {
  ops_.Clear();
}
inline ::suil::tmsp::types::ProofOp* Proof::mutable_ops(int index) {
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.Proof.ops)
  return ops_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::ProofOp >*
Proof::mutable_ops() {
  // @@protoc_insertion_point(field_mutable_list:suil.tmsp.types.Proof.ops)
  return &ops_;
}
inline const ::suil::tmsp::types::ProofOp& Proof::ops(int index) const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Proof.ops)
  return ops_.Get(index);
}
inline ::suil::tmsp::types::ProofOp* Proof::add_ops() {
  // @@protoc_insertion_point(field_add:suil.tmsp.types.Proof.ops)
  return ops_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::ProofOp >&
Proof::ops() const {
  // @@protoc_insertion_point(field_list:suil.tmsp.types.Proof.ops)
  return ops_;
}

// -------------------------------------------------------------------

// KVPair

// bytes key = 1;
inline void KVPair::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KVPair::key() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.KVPair.key)
  return key_.GetNoArena();
}
inline void KVPair::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.KVPair.key)
}
#if LANG_CXX11
inline void KVPair::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.KVPair.key)
}
#endif
inline void KVPair::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.KVPair.key)
}
inline void KVPair::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.KVPair.key)
}
inline ::std::string* KVPair::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.KVPair.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KVPair::release_key() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.KVPair.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KVPair::set_allocated_key(::std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.KVPair.key)
}

// bytes value = 2;
inline void KVPair::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KVPair::value() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.KVPair.value)
  return value_.GetNoArena();
}
inline void KVPair::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.KVPair.value)
}
#if LANG_CXX11
inline void KVPair::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.KVPair.value)
}
#endif
inline void KVPair::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.KVPair.value)
}
inline void KVPair::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.KVPair.value)
}
inline ::std::string* KVPair::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.KVPair.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KVPair::release_value() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.KVPair.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KVPair::set_allocated_value(::std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.KVPair.value)
}

// -------------------------------------------------------------------

// KI64Pair

// bytes key = 1;
inline void KI64Pair::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KI64Pair::key() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.KI64Pair.key)
  return key_.GetNoArena();
}
inline void KI64Pair::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.KI64Pair.key)
}
#if LANG_CXX11
inline void KI64Pair::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.KI64Pair.key)
}
#endif
inline void KI64Pair::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.KI64Pair.key)
}
inline void KI64Pair::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.KI64Pair.key)
}
inline ::std::string* KI64Pair::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.KI64Pair.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KI64Pair::release_key() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.KI64Pair.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KI64Pair::set_allocated_key(::std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.KI64Pair.key)
}

// int64 value = 2;
inline void KI64Pair::clear_value() {
  value_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 KI64Pair::value() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.KI64Pair.value)
  return value_;
}
inline void KI64Pair::set_value(::google::protobuf::int64 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:suil.tmsp.types.KI64Pair.value)
}

// -------------------------------------------------------------------

// Timestamp

// int64 seconds = 1;
inline void Timestamp::clear_seconds() {
  seconds_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 Timestamp::seconds() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Timestamp.seconds)
  return seconds_;
}
inline void Timestamp::set_seconds(::google::protobuf::int64 value) {
  
  seconds_ = value;
  // @@protoc_insertion_point(field_set:suil.tmsp.types.Timestamp.seconds)
}

// int32 nanos = 2;
inline void Timestamp::clear_nanos() {
  nanos_ = 0;
}
inline ::google::protobuf::int32 Timestamp::nanos() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Timestamp.nanos)
  return nanos_;
}
inline void Timestamp::set_nanos(::google::protobuf::int32 value) {
  
  nanos_ = value;
  // @@protoc_insertion_point(field_set:suil.tmsp.types.Timestamp.nanos)
}

// -------------------------------------------------------------------

// Request

// .suil.tmsp.types.RequestEcho echo = 2;
inline bool Request::has_echo() const {
  return value_case() == kEcho;
}
inline void Request::set_has_echo() {
  _oneof_case_[0] = kEcho;
}
inline void Request::clear_echo() {
  if (has_echo()) {
    delete value_.echo_;
    clear_has_value();
  }
}
inline ::suil::tmsp::types::RequestEcho* Request::release_echo() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.Request.echo)
  if (has_echo()) {
    clear_has_value();
      ::suil::tmsp::types::RequestEcho* temp = value_.echo_;
    value_.echo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::suil::tmsp::types::RequestEcho& Request::echo() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Request.echo)
  return has_echo()
      ? *value_.echo_
      : *reinterpret_cast< ::suil::tmsp::types::RequestEcho*>(&::suil::tmsp::types::_RequestEcho_default_instance_);
}
inline ::suil::tmsp::types::RequestEcho* Request::mutable_echo() {
  if (!has_echo()) {
    clear_value();
    set_has_echo();
    value_.echo_ = CreateMaybeMessage< ::suil::tmsp::types::RequestEcho >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.Request.echo)
  return value_.echo_;
}

// .suil.tmsp.types.RequestFlush flush = 3;
inline bool Request::has_flush() const {
  return value_case() == kFlush;
}
inline void Request::set_has_flush() {
  _oneof_case_[0] = kFlush;
}
inline void Request::clear_flush() {
  if (has_flush()) {
    delete value_.flush_;
    clear_has_value();
  }
}
inline ::suil::tmsp::types::RequestFlush* Request::release_flush() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.Request.flush)
  if (has_flush()) {
    clear_has_value();
      ::suil::tmsp::types::RequestFlush* temp = value_.flush_;
    value_.flush_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::suil::tmsp::types::RequestFlush& Request::flush() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Request.flush)
  return has_flush()
      ? *value_.flush_
      : *reinterpret_cast< ::suil::tmsp::types::RequestFlush*>(&::suil::tmsp::types::_RequestFlush_default_instance_);
}
inline ::suil::tmsp::types::RequestFlush* Request::mutable_flush() {
  if (!has_flush()) {
    clear_value();
    set_has_flush();
    value_.flush_ = CreateMaybeMessage< ::suil::tmsp::types::RequestFlush >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.Request.flush)
  return value_.flush_;
}

// .suil.tmsp.types.RequestInfo info = 4;
inline bool Request::has_info() const {
  return value_case() == kInfo;
}
inline void Request::set_has_info() {
  _oneof_case_[0] = kInfo;
}
inline void Request::clear_info() {
  if (has_info()) {
    delete value_.info_;
    clear_has_value();
  }
}
inline ::suil::tmsp::types::RequestInfo* Request::release_info() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.Request.info)
  if (has_info()) {
    clear_has_value();
      ::suil::tmsp::types::RequestInfo* temp = value_.info_;
    value_.info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::suil::tmsp::types::RequestInfo& Request::info() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Request.info)
  return has_info()
      ? *value_.info_
      : *reinterpret_cast< ::suil::tmsp::types::RequestInfo*>(&::suil::tmsp::types::_RequestInfo_default_instance_);
}
inline ::suil::tmsp::types::RequestInfo* Request::mutable_info() {
  if (!has_info()) {
    clear_value();
    set_has_info();
    value_.info_ = CreateMaybeMessage< ::suil::tmsp::types::RequestInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.Request.info)
  return value_.info_;
}

// .suil.tmsp.types.RequestSetOption set_option = 5;
inline bool Request::has_set_option() const {
  return value_case() == kSetOption;
}
inline void Request::set_has_set_option() {
  _oneof_case_[0] = kSetOption;
}
inline void Request::clear_set_option() {
  if (has_set_option()) {
    delete value_.set_option_;
    clear_has_value();
  }
}
inline ::suil::tmsp::types::RequestSetOption* Request::release_set_option() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.Request.set_option)
  if (has_set_option()) {
    clear_has_value();
      ::suil::tmsp::types::RequestSetOption* temp = value_.set_option_;
    value_.set_option_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::suil::tmsp::types::RequestSetOption& Request::set_option() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Request.set_option)
  return has_set_option()
      ? *value_.set_option_
      : *reinterpret_cast< ::suil::tmsp::types::RequestSetOption*>(&::suil::tmsp::types::_RequestSetOption_default_instance_);
}
inline ::suil::tmsp::types::RequestSetOption* Request::mutable_set_option() {
  if (!has_set_option()) {
    clear_value();
    set_has_set_option();
    value_.set_option_ = CreateMaybeMessage< ::suil::tmsp::types::RequestSetOption >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.Request.set_option)
  return value_.set_option_;
}

// .suil.tmsp.types.RequestInitChain init_chain = 6;
inline bool Request::has_init_chain() const {
  return value_case() == kInitChain;
}
inline void Request::set_has_init_chain() {
  _oneof_case_[0] = kInitChain;
}
inline void Request::clear_init_chain() {
  if (has_init_chain()) {
    delete value_.init_chain_;
    clear_has_value();
  }
}
inline ::suil::tmsp::types::RequestInitChain* Request::release_init_chain() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.Request.init_chain)
  if (has_init_chain()) {
    clear_has_value();
      ::suil::tmsp::types::RequestInitChain* temp = value_.init_chain_;
    value_.init_chain_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::suil::tmsp::types::RequestInitChain& Request::init_chain() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Request.init_chain)
  return has_init_chain()
      ? *value_.init_chain_
      : *reinterpret_cast< ::suil::tmsp::types::RequestInitChain*>(&::suil::tmsp::types::_RequestInitChain_default_instance_);
}
inline ::suil::tmsp::types::RequestInitChain* Request::mutable_init_chain() {
  if (!has_init_chain()) {
    clear_value();
    set_has_init_chain();
    value_.init_chain_ = CreateMaybeMessage< ::suil::tmsp::types::RequestInitChain >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.Request.init_chain)
  return value_.init_chain_;
}

// .suil.tmsp.types.RequestQuery query = 7;
inline bool Request::has_query() const {
  return value_case() == kQuery;
}
inline void Request::set_has_query() {
  _oneof_case_[0] = kQuery;
}
inline void Request::clear_query() {
  if (has_query()) {
    delete value_.query_;
    clear_has_value();
  }
}
inline ::suil::tmsp::types::RequestQuery* Request::release_query() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.Request.query)
  if (has_query()) {
    clear_has_value();
      ::suil::tmsp::types::RequestQuery* temp = value_.query_;
    value_.query_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::suil::tmsp::types::RequestQuery& Request::query() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Request.query)
  return has_query()
      ? *value_.query_
      : *reinterpret_cast< ::suil::tmsp::types::RequestQuery*>(&::suil::tmsp::types::_RequestQuery_default_instance_);
}
inline ::suil::tmsp::types::RequestQuery* Request::mutable_query() {
  if (!has_query()) {
    clear_value();
    set_has_query();
    value_.query_ = CreateMaybeMessage< ::suil::tmsp::types::RequestQuery >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.Request.query)
  return value_.query_;
}

// .suil.tmsp.types.RequestBeginBlock begin_block = 8;
inline bool Request::has_begin_block() const {
  return value_case() == kBeginBlock;
}
inline void Request::set_has_begin_block() {
  _oneof_case_[0] = kBeginBlock;
}
inline void Request::clear_begin_block() {
  if (has_begin_block()) {
    delete value_.begin_block_;
    clear_has_value();
  }
}
inline ::suil::tmsp::types::RequestBeginBlock* Request::release_begin_block() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.Request.begin_block)
  if (has_begin_block()) {
    clear_has_value();
      ::suil::tmsp::types::RequestBeginBlock* temp = value_.begin_block_;
    value_.begin_block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::suil::tmsp::types::RequestBeginBlock& Request::begin_block() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Request.begin_block)
  return has_begin_block()
      ? *value_.begin_block_
      : *reinterpret_cast< ::suil::tmsp::types::RequestBeginBlock*>(&::suil::tmsp::types::_RequestBeginBlock_default_instance_);
}
inline ::suil::tmsp::types::RequestBeginBlock* Request::mutable_begin_block() {
  if (!has_begin_block()) {
    clear_value();
    set_has_begin_block();
    value_.begin_block_ = CreateMaybeMessage< ::suil::tmsp::types::RequestBeginBlock >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.Request.begin_block)
  return value_.begin_block_;
}

// .suil.tmsp.types.RequestCheckTx check_tx = 9;
inline bool Request::has_check_tx() const {
  return value_case() == kCheckTx;
}
inline void Request::set_has_check_tx() {
  _oneof_case_[0] = kCheckTx;
}
inline void Request::clear_check_tx() {
  if (has_check_tx()) {
    delete value_.check_tx_;
    clear_has_value();
  }
}
inline ::suil::tmsp::types::RequestCheckTx* Request::release_check_tx() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.Request.check_tx)
  if (has_check_tx()) {
    clear_has_value();
      ::suil::tmsp::types::RequestCheckTx* temp = value_.check_tx_;
    value_.check_tx_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::suil::tmsp::types::RequestCheckTx& Request::check_tx() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Request.check_tx)
  return has_check_tx()
      ? *value_.check_tx_
      : *reinterpret_cast< ::suil::tmsp::types::RequestCheckTx*>(&::suil::tmsp::types::_RequestCheckTx_default_instance_);
}
inline ::suil::tmsp::types::RequestCheckTx* Request::mutable_check_tx() {
  if (!has_check_tx()) {
    clear_value();
    set_has_check_tx();
    value_.check_tx_ = CreateMaybeMessage< ::suil::tmsp::types::RequestCheckTx >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.Request.check_tx)
  return value_.check_tx_;
}

// .suil.tmsp.types.RequestDeliverTx deliver_tx = 19;
inline bool Request::has_deliver_tx() const {
  return value_case() == kDeliverTx;
}
inline void Request::set_has_deliver_tx() {
  _oneof_case_[0] = kDeliverTx;
}
inline void Request::clear_deliver_tx() {
  if (has_deliver_tx()) {
    delete value_.deliver_tx_;
    clear_has_value();
  }
}
inline ::suil::tmsp::types::RequestDeliverTx* Request::release_deliver_tx() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.Request.deliver_tx)
  if (has_deliver_tx()) {
    clear_has_value();
      ::suil::tmsp::types::RequestDeliverTx* temp = value_.deliver_tx_;
    value_.deliver_tx_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::suil::tmsp::types::RequestDeliverTx& Request::deliver_tx() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Request.deliver_tx)
  return has_deliver_tx()
      ? *value_.deliver_tx_
      : *reinterpret_cast< ::suil::tmsp::types::RequestDeliverTx*>(&::suil::tmsp::types::_RequestDeliverTx_default_instance_);
}
inline ::suil::tmsp::types::RequestDeliverTx* Request::mutable_deliver_tx() {
  if (!has_deliver_tx()) {
    clear_value();
    set_has_deliver_tx();
    value_.deliver_tx_ = CreateMaybeMessage< ::suil::tmsp::types::RequestDeliverTx >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.Request.deliver_tx)
  return value_.deliver_tx_;
}

// .suil.tmsp.types.RequestEndBlock end_block = 11;
inline bool Request::has_end_block() const {
  return value_case() == kEndBlock;
}
inline void Request::set_has_end_block() {
  _oneof_case_[0] = kEndBlock;
}
inline void Request::clear_end_block() {
  if (has_end_block()) {
    delete value_.end_block_;
    clear_has_value();
  }
}
inline ::suil::tmsp::types::RequestEndBlock* Request::release_end_block() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.Request.end_block)
  if (has_end_block()) {
    clear_has_value();
      ::suil::tmsp::types::RequestEndBlock* temp = value_.end_block_;
    value_.end_block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::suil::tmsp::types::RequestEndBlock& Request::end_block() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Request.end_block)
  return has_end_block()
      ? *value_.end_block_
      : *reinterpret_cast< ::suil::tmsp::types::RequestEndBlock*>(&::suil::tmsp::types::_RequestEndBlock_default_instance_);
}
inline ::suil::tmsp::types::RequestEndBlock* Request::mutable_end_block() {
  if (!has_end_block()) {
    clear_value();
    set_has_end_block();
    value_.end_block_ = CreateMaybeMessage< ::suil::tmsp::types::RequestEndBlock >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.Request.end_block)
  return value_.end_block_;
}

// .suil.tmsp.types.RequestCommit commit = 12;
inline bool Request::has_commit() const {
  return value_case() == kCommit;
}
inline void Request::set_has_commit() {
  _oneof_case_[0] = kCommit;
}
inline void Request::clear_commit() {
  if (has_commit()) {
    delete value_.commit_;
    clear_has_value();
  }
}
inline ::suil::tmsp::types::RequestCommit* Request::release_commit() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.Request.commit)
  if (has_commit()) {
    clear_has_value();
      ::suil::tmsp::types::RequestCommit* temp = value_.commit_;
    value_.commit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::suil::tmsp::types::RequestCommit& Request::commit() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Request.commit)
  return has_commit()
      ? *value_.commit_
      : *reinterpret_cast< ::suil::tmsp::types::RequestCommit*>(&::suil::tmsp::types::_RequestCommit_default_instance_);
}
inline ::suil::tmsp::types::RequestCommit* Request::mutable_commit() {
  if (!has_commit()) {
    clear_value();
    set_has_commit();
    value_.commit_ = CreateMaybeMessage< ::suil::tmsp::types::RequestCommit >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.Request.commit)
  return value_.commit_;
}

inline bool Request::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Request::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline Request::ValueCase Request::value_case() const {
  return Request::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RequestEcho

// string message = 1;
inline void RequestEcho::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RequestEcho::message() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.RequestEcho.message)
  return message_.GetNoArena();
}
inline void RequestEcho::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.RequestEcho.message)
}
#if LANG_CXX11
inline void RequestEcho::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.RequestEcho.message)
}
#endif
inline void RequestEcho::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.RequestEcho.message)
}
inline void RequestEcho::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.RequestEcho.message)
}
inline ::std::string* RequestEcho::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.RequestEcho.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestEcho::release_message() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.RequestEcho.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestEcho::set_allocated_message(::std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.RequestEcho.message)
}

// -------------------------------------------------------------------

// RequestFlush

// -------------------------------------------------------------------

// RequestInfo

// string version = 1;
inline void RequestInfo::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RequestInfo::version() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.RequestInfo.version)
  return version_.GetNoArena();
}
inline void RequestInfo::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.RequestInfo.version)
}
#if LANG_CXX11
inline void RequestInfo::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.RequestInfo.version)
}
#endif
inline void RequestInfo::set_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.RequestInfo.version)
}
inline void RequestInfo::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.RequestInfo.version)
}
inline ::std::string* RequestInfo::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.RequestInfo.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestInfo::release_version() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.RequestInfo.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestInfo::set_allocated_version(::std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.RequestInfo.version)
}

// uint64 block_version = 2;
inline void RequestInfo::clear_block_version() {
  block_version_ = PROTOBUF_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RequestInfo::block_version() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.RequestInfo.block_version)
  return block_version_;
}
inline void RequestInfo::set_block_version(::google::protobuf::uint64 value) {
  
  block_version_ = value;
  // @@protoc_insertion_point(field_set:suil.tmsp.types.RequestInfo.block_version)
}

// uint64 p2p_version = 3;
inline void RequestInfo::clear_p2p_version() {
  p2p_version_ = PROTOBUF_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RequestInfo::p2p_version() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.RequestInfo.p2p_version)
  return p2p_version_;
}
inline void RequestInfo::set_p2p_version(::google::protobuf::uint64 value) {
  
  p2p_version_ = value;
  // @@protoc_insertion_point(field_set:suil.tmsp.types.RequestInfo.p2p_version)
}

// -------------------------------------------------------------------

// RequestSetOption

// string key = 1;
inline void RequestSetOption::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RequestSetOption::key() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.RequestSetOption.key)
  return key_.GetNoArena();
}
inline void RequestSetOption::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.RequestSetOption.key)
}
#if LANG_CXX11
inline void RequestSetOption::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.RequestSetOption.key)
}
#endif
inline void RequestSetOption::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.RequestSetOption.key)
}
inline void RequestSetOption::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.RequestSetOption.key)
}
inline ::std::string* RequestSetOption::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.RequestSetOption.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestSetOption::release_key() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.RequestSetOption.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestSetOption::set_allocated_key(::std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.RequestSetOption.key)
}

// string value = 2;
inline void RequestSetOption::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RequestSetOption::value() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.RequestSetOption.value)
  return value_.GetNoArena();
}
inline void RequestSetOption::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.RequestSetOption.value)
}
#if LANG_CXX11
inline void RequestSetOption::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.RequestSetOption.value)
}
#endif
inline void RequestSetOption::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.RequestSetOption.value)
}
inline void RequestSetOption::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.RequestSetOption.value)
}
inline ::std::string* RequestSetOption::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.RequestSetOption.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestSetOption::release_value() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.RequestSetOption.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestSetOption::set_allocated_value(::std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.RequestSetOption.value)
}

// -------------------------------------------------------------------

// RequestInitChain

// .suil.tmsp.types.Timestamp time = 1;
inline bool RequestInitChain::has_time() const {
  return this != internal_default_instance() && time_ != nullptr;
}
inline void RequestInitChain::clear_time() {
  if (GetArenaNoVirtual() == nullptr && time_ != nullptr) {
    delete time_;
  }
  time_ = nullptr;
}
inline const ::suil::tmsp::types::Timestamp& RequestInitChain::time() const {
  const ::suil::tmsp::types::Timestamp* p = time_;
  // @@protoc_insertion_point(field_get:suil.tmsp.types.RequestInitChain.time)
  return p != nullptr ? *p : *reinterpret_cast<const ::suil::tmsp::types::Timestamp*>(
      &::suil::tmsp::types::_Timestamp_default_instance_);
}
inline ::suil::tmsp::types::Timestamp* RequestInitChain::release_time() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.RequestInitChain.time)
  
  ::suil::tmsp::types::Timestamp* temp = time_;
  time_ = nullptr;
  return temp;
}
inline ::suil::tmsp::types::Timestamp* RequestInitChain::mutable_time() {
  
  if (time_ == nullptr) {
    auto* p = CreateMaybeMessage<::suil::tmsp::types::Timestamp>(GetArenaNoVirtual());
    time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.RequestInitChain.time)
  return time_;
}
inline void RequestInitChain::set_allocated_time(::suil::tmsp::types::Timestamp* time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete time_;
  }
  if (time) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    
  } else {
    
  }
  time_ = time;
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.RequestInitChain.time)
}

// string chain_id = 2;
inline void RequestInitChain::clear_chain_id() {
  chain_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RequestInitChain::chain_id() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.RequestInitChain.chain_id)
  return chain_id_.GetNoArena();
}
inline void RequestInitChain::set_chain_id(const ::std::string& value) {
  
  chain_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.RequestInitChain.chain_id)
}
#if LANG_CXX11
inline void RequestInitChain::set_chain_id(::std::string&& value) {
  
  chain_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.RequestInitChain.chain_id)
}
#endif
inline void RequestInitChain::set_chain_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  chain_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.RequestInitChain.chain_id)
}
inline void RequestInitChain::set_chain_id(const char* value, size_t size) {
  
  chain_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.RequestInitChain.chain_id)
}
inline ::std::string* RequestInitChain::mutable_chain_id() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.RequestInitChain.chain_id)
  return chain_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestInitChain::release_chain_id() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.RequestInitChain.chain_id)
  
  return chain_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestInitChain::set_allocated_chain_id(::std::string* chain_id) {
  if (chain_id != nullptr) {
    
  } else {
    
  }
  chain_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), chain_id);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.RequestInitChain.chain_id)
}

// .suil.tmsp.types.ConsensusParams consensus_params = 3;
inline bool RequestInitChain::has_consensus_params() const {
  return this != internal_default_instance() && consensus_params_ != nullptr;
}
inline void RequestInitChain::clear_consensus_params() {
  if (GetArenaNoVirtual() == nullptr && consensus_params_ != nullptr) {
    delete consensus_params_;
  }
  consensus_params_ = nullptr;
}
inline const ::suil::tmsp::types::ConsensusParams& RequestInitChain::consensus_params() const {
  const ::suil::tmsp::types::ConsensusParams* p = consensus_params_;
  // @@protoc_insertion_point(field_get:suil.tmsp.types.RequestInitChain.consensus_params)
  return p != nullptr ? *p : *reinterpret_cast<const ::suil::tmsp::types::ConsensusParams*>(
      &::suil::tmsp::types::_ConsensusParams_default_instance_);
}
inline ::suil::tmsp::types::ConsensusParams* RequestInitChain::release_consensus_params() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.RequestInitChain.consensus_params)
  
  ::suil::tmsp::types::ConsensusParams* temp = consensus_params_;
  consensus_params_ = nullptr;
  return temp;
}
inline ::suil::tmsp::types::ConsensusParams* RequestInitChain::mutable_consensus_params() {
  
  if (consensus_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::suil::tmsp::types::ConsensusParams>(GetArenaNoVirtual());
    consensus_params_ = p;
  }
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.RequestInitChain.consensus_params)
  return consensus_params_;
}
inline void RequestInitChain::set_allocated_consensus_params(::suil::tmsp::types::ConsensusParams* consensus_params) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete consensus_params_;
  }
  if (consensus_params) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      consensus_params = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, consensus_params, submessage_arena);
    }
    
  } else {
    
  }
  consensus_params_ = consensus_params;
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.RequestInitChain.consensus_params)
}

// repeated .suil.tmsp.types.ValidatorUpdate validators = 4;
inline int RequestInitChain::validators_size() const {
  return validators_.size();
}
inline void RequestInitChain::clear_validators() {
  validators_.Clear();
}
inline ::suil::tmsp::types::ValidatorUpdate* RequestInitChain::mutable_validators(int index) {
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.RequestInitChain.validators)
  return validators_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::ValidatorUpdate >*
RequestInitChain::mutable_validators() {
  // @@protoc_insertion_point(field_mutable_list:suil.tmsp.types.RequestInitChain.validators)
  return &validators_;
}
inline const ::suil::tmsp::types::ValidatorUpdate& RequestInitChain::validators(int index) const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.RequestInitChain.validators)
  return validators_.Get(index);
}
inline ::suil::tmsp::types::ValidatorUpdate* RequestInitChain::add_validators() {
  // @@protoc_insertion_point(field_add:suil.tmsp.types.RequestInitChain.validators)
  return validators_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::ValidatorUpdate >&
RequestInitChain::validators() const {
  // @@protoc_insertion_point(field_list:suil.tmsp.types.RequestInitChain.validators)
  return validators_;
}

// bytes app_state_bytes = 5;
inline void RequestInitChain::clear_app_state_bytes() {
  app_state_bytes_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RequestInitChain::app_state_bytes() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.RequestInitChain.app_state_bytes)
  return app_state_bytes_.GetNoArena();
}
inline void RequestInitChain::set_app_state_bytes(const ::std::string& value) {
  
  app_state_bytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.RequestInitChain.app_state_bytes)
}
#if LANG_CXX11
inline void RequestInitChain::set_app_state_bytes(::std::string&& value) {
  
  app_state_bytes_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.RequestInitChain.app_state_bytes)
}
#endif
inline void RequestInitChain::set_app_state_bytes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  app_state_bytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.RequestInitChain.app_state_bytes)
}
inline void RequestInitChain::set_app_state_bytes(const void* value, size_t size) {
  
  app_state_bytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.RequestInitChain.app_state_bytes)
}
inline ::std::string* RequestInitChain::mutable_app_state_bytes() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.RequestInitChain.app_state_bytes)
  return app_state_bytes_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestInitChain::release_app_state_bytes() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.RequestInitChain.app_state_bytes)
  
  return app_state_bytes_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestInitChain::set_allocated_app_state_bytes(::std::string* app_state_bytes) {
  if (app_state_bytes != nullptr) {
    
  } else {
    
  }
  app_state_bytes_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), app_state_bytes);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.RequestInitChain.app_state_bytes)
}

// -------------------------------------------------------------------

// RequestQuery

// bytes data = 1;
inline void RequestQuery::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RequestQuery::data() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.RequestQuery.data)
  return data_.GetNoArena();
}
inline void RequestQuery::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.RequestQuery.data)
}
#if LANG_CXX11
inline void RequestQuery::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.RequestQuery.data)
}
#endif
inline void RequestQuery::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.RequestQuery.data)
}
inline void RequestQuery::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.RequestQuery.data)
}
inline ::std::string* RequestQuery::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.RequestQuery.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestQuery::release_data() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.RequestQuery.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestQuery::set_allocated_data(::std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.RequestQuery.data)
}

// string path = 2;
inline void RequestQuery::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RequestQuery::path() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.RequestQuery.path)
  return path_.GetNoArena();
}
inline void RequestQuery::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.RequestQuery.path)
}
#if LANG_CXX11
inline void RequestQuery::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.RequestQuery.path)
}
#endif
inline void RequestQuery::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.RequestQuery.path)
}
inline void RequestQuery::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.RequestQuery.path)
}
inline ::std::string* RequestQuery::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.RequestQuery.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestQuery::release_path() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.RequestQuery.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestQuery::set_allocated_path(::std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.RequestQuery.path)
}

// int64 height = 3;
inline void RequestQuery::clear_height() {
  height_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 RequestQuery::height() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.RequestQuery.height)
  return height_;
}
inline void RequestQuery::set_height(::google::protobuf::int64 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:suil.tmsp.types.RequestQuery.height)
}

// bool prove = 4;
inline void RequestQuery::clear_prove() {
  prove_ = false;
}
inline bool RequestQuery::prove() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.RequestQuery.prove)
  return prove_;
}
inline void RequestQuery::set_prove(bool value) {
  
  prove_ = value;
  // @@protoc_insertion_point(field_set:suil.tmsp.types.RequestQuery.prove)
}

// -------------------------------------------------------------------

// RequestBeginBlock

// bytes hash = 1;
inline void RequestBeginBlock::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RequestBeginBlock::hash() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.RequestBeginBlock.hash)
  return hash_.GetNoArena();
}
inline void RequestBeginBlock::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.RequestBeginBlock.hash)
}
#if LANG_CXX11
inline void RequestBeginBlock::set_hash(::std::string&& value) {
  
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.RequestBeginBlock.hash)
}
#endif
inline void RequestBeginBlock::set_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.RequestBeginBlock.hash)
}
inline void RequestBeginBlock::set_hash(const void* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.RequestBeginBlock.hash)
}
inline ::std::string* RequestBeginBlock::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.RequestBeginBlock.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestBeginBlock::release_hash() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.RequestBeginBlock.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestBeginBlock::set_allocated_hash(::std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.RequestBeginBlock.hash)
}

// .suil.tmsp.types.Header header = 2;
inline bool RequestBeginBlock::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void RequestBeginBlock::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::suil::tmsp::types::Header& RequestBeginBlock::header() const {
  const ::suil::tmsp::types::Header* p = header_;
  // @@protoc_insertion_point(field_get:suil.tmsp.types.RequestBeginBlock.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::suil::tmsp::types::Header*>(
      &::suil::tmsp::types::_Header_default_instance_);
}
inline ::suil::tmsp::types::Header* RequestBeginBlock::release_header() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.RequestBeginBlock.header)
  
  ::suil::tmsp::types::Header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::suil::tmsp::types::Header* RequestBeginBlock::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::suil::tmsp::types::Header>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.RequestBeginBlock.header)
  return header_;
}
inline void RequestBeginBlock::set_allocated_header(::suil::tmsp::types::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.RequestBeginBlock.header)
}

// .suil.tmsp.types.LastCommitInfo last_commit_info = 3;
inline bool RequestBeginBlock::has_last_commit_info() const {
  return this != internal_default_instance() && last_commit_info_ != nullptr;
}
inline void RequestBeginBlock::clear_last_commit_info() {
  if (GetArenaNoVirtual() == nullptr && last_commit_info_ != nullptr) {
    delete last_commit_info_;
  }
  last_commit_info_ = nullptr;
}
inline const ::suil::tmsp::types::LastCommitInfo& RequestBeginBlock::last_commit_info() const {
  const ::suil::tmsp::types::LastCommitInfo* p = last_commit_info_;
  // @@protoc_insertion_point(field_get:suil.tmsp.types.RequestBeginBlock.last_commit_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::suil::tmsp::types::LastCommitInfo*>(
      &::suil::tmsp::types::_LastCommitInfo_default_instance_);
}
inline ::suil::tmsp::types::LastCommitInfo* RequestBeginBlock::release_last_commit_info() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.RequestBeginBlock.last_commit_info)
  
  ::suil::tmsp::types::LastCommitInfo* temp = last_commit_info_;
  last_commit_info_ = nullptr;
  return temp;
}
inline ::suil::tmsp::types::LastCommitInfo* RequestBeginBlock::mutable_last_commit_info() {
  
  if (last_commit_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::suil::tmsp::types::LastCommitInfo>(GetArenaNoVirtual());
    last_commit_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.RequestBeginBlock.last_commit_info)
  return last_commit_info_;
}
inline void RequestBeginBlock::set_allocated_last_commit_info(::suil::tmsp::types::LastCommitInfo* last_commit_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete last_commit_info_;
  }
  if (last_commit_info) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      last_commit_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, last_commit_info, submessage_arena);
    }
    
  } else {
    
  }
  last_commit_info_ = last_commit_info;
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.RequestBeginBlock.last_commit_info)
}

// repeated .suil.tmsp.types.Evidence byzantine_validators = 4;
inline int RequestBeginBlock::byzantine_validators_size() const {
  return byzantine_validators_.size();
}
inline void RequestBeginBlock::clear_byzantine_validators() {
  byzantine_validators_.Clear();
}
inline ::suil::tmsp::types::Evidence* RequestBeginBlock::mutable_byzantine_validators(int index) {
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.RequestBeginBlock.byzantine_validators)
  return byzantine_validators_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::Evidence >*
RequestBeginBlock::mutable_byzantine_validators() {
  // @@protoc_insertion_point(field_mutable_list:suil.tmsp.types.RequestBeginBlock.byzantine_validators)
  return &byzantine_validators_;
}
inline const ::suil::tmsp::types::Evidence& RequestBeginBlock::byzantine_validators(int index) const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.RequestBeginBlock.byzantine_validators)
  return byzantine_validators_.Get(index);
}
inline ::suil::tmsp::types::Evidence* RequestBeginBlock::add_byzantine_validators() {
  // @@protoc_insertion_point(field_add:suil.tmsp.types.RequestBeginBlock.byzantine_validators)
  return byzantine_validators_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::Evidence >&
RequestBeginBlock::byzantine_validators() const {
  // @@protoc_insertion_point(field_list:suil.tmsp.types.RequestBeginBlock.byzantine_validators)
  return byzantine_validators_;
}

// -------------------------------------------------------------------

// RequestCheckTx

// bytes tx = 1;
inline void RequestCheckTx::clear_tx() {
  tx_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RequestCheckTx::tx() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.RequestCheckTx.tx)
  return tx_.GetNoArena();
}
inline void RequestCheckTx::set_tx(const ::std::string& value) {
  
  tx_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.RequestCheckTx.tx)
}
#if LANG_CXX11
inline void RequestCheckTx::set_tx(::std::string&& value) {
  
  tx_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.RequestCheckTx.tx)
}
#endif
inline void RequestCheckTx::set_tx(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  tx_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.RequestCheckTx.tx)
}
inline void RequestCheckTx::set_tx(const void* value, size_t size) {
  
  tx_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.RequestCheckTx.tx)
}
inline ::std::string* RequestCheckTx::mutable_tx() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.RequestCheckTx.tx)
  return tx_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestCheckTx::release_tx() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.RequestCheckTx.tx)
  
  return tx_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestCheckTx::set_allocated_tx(::std::string* tx) {
  if (tx != nullptr) {
    
  } else {
    
  }
  tx_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tx);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.RequestCheckTx.tx)
}

// -------------------------------------------------------------------

// RequestDeliverTx

// bytes tx = 1;
inline void RequestDeliverTx::clear_tx() {
  tx_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RequestDeliverTx::tx() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.RequestDeliverTx.tx)
  return tx_.GetNoArena();
}
inline void RequestDeliverTx::set_tx(const ::std::string& value) {
  
  tx_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.RequestDeliverTx.tx)
}
#if LANG_CXX11
inline void RequestDeliverTx::set_tx(::std::string&& value) {
  
  tx_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.RequestDeliverTx.tx)
}
#endif
inline void RequestDeliverTx::set_tx(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  tx_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.RequestDeliverTx.tx)
}
inline void RequestDeliverTx::set_tx(const void* value, size_t size) {
  
  tx_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.RequestDeliverTx.tx)
}
inline ::std::string* RequestDeliverTx::mutable_tx() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.RequestDeliverTx.tx)
  return tx_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestDeliverTx::release_tx() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.RequestDeliverTx.tx)
  
  return tx_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestDeliverTx::set_allocated_tx(::std::string* tx) {
  if (tx != nullptr) {
    
  } else {
    
  }
  tx_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tx);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.RequestDeliverTx.tx)
}

// -------------------------------------------------------------------

// RequestEndBlock

// int64 height = 1;
inline void RequestEndBlock::clear_height() {
  height_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 RequestEndBlock::height() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.RequestEndBlock.height)
  return height_;
}
inline void RequestEndBlock::set_height(::google::protobuf::int64 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:suil.tmsp.types.RequestEndBlock.height)
}

// -------------------------------------------------------------------

// RequestCommit

// -------------------------------------------------------------------

// Response

// .suil.tmsp.types.ResponseException exception = 1;
inline bool Response::has_exception() const {
  return value_case() == kException;
}
inline void Response::set_has_exception() {
  _oneof_case_[0] = kException;
}
inline void Response::clear_exception() {
  if (has_exception()) {
    delete value_.exception_;
    clear_has_value();
  }
}
inline ::suil::tmsp::types::ResponseException* Response::release_exception() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.Response.exception)
  if (has_exception()) {
    clear_has_value();
      ::suil::tmsp::types::ResponseException* temp = value_.exception_;
    value_.exception_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::suil::tmsp::types::ResponseException& Response::exception() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Response.exception)
  return has_exception()
      ? *value_.exception_
      : *reinterpret_cast< ::suil::tmsp::types::ResponseException*>(&::suil::tmsp::types::_ResponseException_default_instance_);
}
inline ::suil::tmsp::types::ResponseException* Response::mutable_exception() {
  if (!has_exception()) {
    clear_value();
    set_has_exception();
    value_.exception_ = CreateMaybeMessage< ::suil::tmsp::types::ResponseException >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.Response.exception)
  return value_.exception_;
}

// .suil.tmsp.types.ResponseEcho echo = 2;
inline bool Response::has_echo() const {
  return value_case() == kEcho;
}
inline void Response::set_has_echo() {
  _oneof_case_[0] = kEcho;
}
inline void Response::clear_echo() {
  if (has_echo()) {
    delete value_.echo_;
    clear_has_value();
  }
}
inline ::suil::tmsp::types::ResponseEcho* Response::release_echo() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.Response.echo)
  if (has_echo()) {
    clear_has_value();
      ::suil::tmsp::types::ResponseEcho* temp = value_.echo_;
    value_.echo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::suil::tmsp::types::ResponseEcho& Response::echo() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Response.echo)
  return has_echo()
      ? *value_.echo_
      : *reinterpret_cast< ::suil::tmsp::types::ResponseEcho*>(&::suil::tmsp::types::_ResponseEcho_default_instance_);
}
inline ::suil::tmsp::types::ResponseEcho* Response::mutable_echo() {
  if (!has_echo()) {
    clear_value();
    set_has_echo();
    value_.echo_ = CreateMaybeMessage< ::suil::tmsp::types::ResponseEcho >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.Response.echo)
  return value_.echo_;
}

// .suil.tmsp.types.ResponseFlush flush = 3;
inline bool Response::has_flush() const {
  return value_case() == kFlush;
}
inline void Response::set_has_flush() {
  _oneof_case_[0] = kFlush;
}
inline void Response::clear_flush() {
  if (has_flush()) {
    delete value_.flush_;
    clear_has_value();
  }
}
inline ::suil::tmsp::types::ResponseFlush* Response::release_flush() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.Response.flush)
  if (has_flush()) {
    clear_has_value();
      ::suil::tmsp::types::ResponseFlush* temp = value_.flush_;
    value_.flush_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::suil::tmsp::types::ResponseFlush& Response::flush() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Response.flush)
  return has_flush()
      ? *value_.flush_
      : *reinterpret_cast< ::suil::tmsp::types::ResponseFlush*>(&::suil::tmsp::types::_ResponseFlush_default_instance_);
}
inline ::suil::tmsp::types::ResponseFlush* Response::mutable_flush() {
  if (!has_flush()) {
    clear_value();
    set_has_flush();
    value_.flush_ = CreateMaybeMessage< ::suil::tmsp::types::ResponseFlush >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.Response.flush)
  return value_.flush_;
}

// .suil.tmsp.types.ResponseInfo info = 4;
inline bool Response::has_info() const {
  return value_case() == kInfo;
}
inline void Response::set_has_info() {
  _oneof_case_[0] = kInfo;
}
inline void Response::clear_info() {
  if (has_info()) {
    delete value_.info_;
    clear_has_value();
  }
}
inline ::suil::tmsp::types::ResponseInfo* Response::release_info() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.Response.info)
  if (has_info()) {
    clear_has_value();
      ::suil::tmsp::types::ResponseInfo* temp = value_.info_;
    value_.info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::suil::tmsp::types::ResponseInfo& Response::info() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Response.info)
  return has_info()
      ? *value_.info_
      : *reinterpret_cast< ::suil::tmsp::types::ResponseInfo*>(&::suil::tmsp::types::_ResponseInfo_default_instance_);
}
inline ::suil::tmsp::types::ResponseInfo* Response::mutable_info() {
  if (!has_info()) {
    clear_value();
    set_has_info();
    value_.info_ = CreateMaybeMessage< ::suil::tmsp::types::ResponseInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.Response.info)
  return value_.info_;
}

// .suil.tmsp.types.ResponseSetOption set_option = 5;
inline bool Response::has_set_option() const {
  return value_case() == kSetOption;
}
inline void Response::set_has_set_option() {
  _oneof_case_[0] = kSetOption;
}
inline void Response::clear_set_option() {
  if (has_set_option()) {
    delete value_.set_option_;
    clear_has_value();
  }
}
inline ::suil::tmsp::types::ResponseSetOption* Response::release_set_option() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.Response.set_option)
  if (has_set_option()) {
    clear_has_value();
      ::suil::tmsp::types::ResponseSetOption* temp = value_.set_option_;
    value_.set_option_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::suil::tmsp::types::ResponseSetOption& Response::set_option() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Response.set_option)
  return has_set_option()
      ? *value_.set_option_
      : *reinterpret_cast< ::suil::tmsp::types::ResponseSetOption*>(&::suil::tmsp::types::_ResponseSetOption_default_instance_);
}
inline ::suil::tmsp::types::ResponseSetOption* Response::mutable_set_option() {
  if (!has_set_option()) {
    clear_value();
    set_has_set_option();
    value_.set_option_ = CreateMaybeMessage< ::suil::tmsp::types::ResponseSetOption >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.Response.set_option)
  return value_.set_option_;
}

// .suil.tmsp.types.ResponseInitChain init_chain = 6;
inline bool Response::has_init_chain() const {
  return value_case() == kInitChain;
}
inline void Response::set_has_init_chain() {
  _oneof_case_[0] = kInitChain;
}
inline void Response::clear_init_chain() {
  if (has_init_chain()) {
    delete value_.init_chain_;
    clear_has_value();
  }
}
inline ::suil::tmsp::types::ResponseInitChain* Response::release_init_chain() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.Response.init_chain)
  if (has_init_chain()) {
    clear_has_value();
      ::suil::tmsp::types::ResponseInitChain* temp = value_.init_chain_;
    value_.init_chain_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::suil::tmsp::types::ResponseInitChain& Response::init_chain() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Response.init_chain)
  return has_init_chain()
      ? *value_.init_chain_
      : *reinterpret_cast< ::suil::tmsp::types::ResponseInitChain*>(&::suil::tmsp::types::_ResponseInitChain_default_instance_);
}
inline ::suil::tmsp::types::ResponseInitChain* Response::mutable_init_chain() {
  if (!has_init_chain()) {
    clear_value();
    set_has_init_chain();
    value_.init_chain_ = CreateMaybeMessage< ::suil::tmsp::types::ResponseInitChain >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.Response.init_chain)
  return value_.init_chain_;
}

// .suil.tmsp.types.ResponseQuery query = 7;
inline bool Response::has_query() const {
  return value_case() == kQuery;
}
inline void Response::set_has_query() {
  _oneof_case_[0] = kQuery;
}
inline void Response::clear_query() {
  if (has_query()) {
    delete value_.query_;
    clear_has_value();
  }
}
inline ::suil::tmsp::types::ResponseQuery* Response::release_query() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.Response.query)
  if (has_query()) {
    clear_has_value();
      ::suil::tmsp::types::ResponseQuery* temp = value_.query_;
    value_.query_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::suil::tmsp::types::ResponseQuery& Response::query() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Response.query)
  return has_query()
      ? *value_.query_
      : *reinterpret_cast< ::suil::tmsp::types::ResponseQuery*>(&::suil::tmsp::types::_ResponseQuery_default_instance_);
}
inline ::suil::tmsp::types::ResponseQuery* Response::mutable_query() {
  if (!has_query()) {
    clear_value();
    set_has_query();
    value_.query_ = CreateMaybeMessage< ::suil::tmsp::types::ResponseQuery >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.Response.query)
  return value_.query_;
}

// .suil.tmsp.types.ResponseBeginBlock begin_block = 8;
inline bool Response::has_begin_block() const {
  return value_case() == kBeginBlock;
}
inline void Response::set_has_begin_block() {
  _oneof_case_[0] = kBeginBlock;
}
inline void Response::clear_begin_block() {
  if (has_begin_block()) {
    delete value_.begin_block_;
    clear_has_value();
  }
}
inline ::suil::tmsp::types::ResponseBeginBlock* Response::release_begin_block() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.Response.begin_block)
  if (has_begin_block()) {
    clear_has_value();
      ::suil::tmsp::types::ResponseBeginBlock* temp = value_.begin_block_;
    value_.begin_block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::suil::tmsp::types::ResponseBeginBlock& Response::begin_block() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Response.begin_block)
  return has_begin_block()
      ? *value_.begin_block_
      : *reinterpret_cast< ::suil::tmsp::types::ResponseBeginBlock*>(&::suil::tmsp::types::_ResponseBeginBlock_default_instance_);
}
inline ::suil::tmsp::types::ResponseBeginBlock* Response::mutable_begin_block() {
  if (!has_begin_block()) {
    clear_value();
    set_has_begin_block();
    value_.begin_block_ = CreateMaybeMessage< ::suil::tmsp::types::ResponseBeginBlock >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.Response.begin_block)
  return value_.begin_block_;
}

// .suil.tmsp.types.ResponseCheckTx check_tx = 9;
inline bool Response::has_check_tx() const {
  return value_case() == kCheckTx;
}
inline void Response::set_has_check_tx() {
  _oneof_case_[0] = kCheckTx;
}
inline void Response::clear_check_tx() {
  if (has_check_tx()) {
    delete value_.check_tx_;
    clear_has_value();
  }
}
inline ::suil::tmsp::types::ResponseCheckTx* Response::release_check_tx() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.Response.check_tx)
  if (has_check_tx()) {
    clear_has_value();
      ::suil::tmsp::types::ResponseCheckTx* temp = value_.check_tx_;
    value_.check_tx_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::suil::tmsp::types::ResponseCheckTx& Response::check_tx() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Response.check_tx)
  return has_check_tx()
      ? *value_.check_tx_
      : *reinterpret_cast< ::suil::tmsp::types::ResponseCheckTx*>(&::suil::tmsp::types::_ResponseCheckTx_default_instance_);
}
inline ::suil::tmsp::types::ResponseCheckTx* Response::mutable_check_tx() {
  if (!has_check_tx()) {
    clear_value();
    set_has_check_tx();
    value_.check_tx_ = CreateMaybeMessage< ::suil::tmsp::types::ResponseCheckTx >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.Response.check_tx)
  return value_.check_tx_;
}

// .suil.tmsp.types.ResponseDeliverTx deliver_tx = 10;
inline bool Response::has_deliver_tx() const {
  return value_case() == kDeliverTx;
}
inline void Response::set_has_deliver_tx() {
  _oneof_case_[0] = kDeliverTx;
}
inline void Response::clear_deliver_tx() {
  if (has_deliver_tx()) {
    delete value_.deliver_tx_;
    clear_has_value();
  }
}
inline ::suil::tmsp::types::ResponseDeliverTx* Response::release_deliver_tx() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.Response.deliver_tx)
  if (has_deliver_tx()) {
    clear_has_value();
      ::suil::tmsp::types::ResponseDeliverTx* temp = value_.deliver_tx_;
    value_.deliver_tx_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::suil::tmsp::types::ResponseDeliverTx& Response::deliver_tx() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Response.deliver_tx)
  return has_deliver_tx()
      ? *value_.deliver_tx_
      : *reinterpret_cast< ::suil::tmsp::types::ResponseDeliverTx*>(&::suil::tmsp::types::_ResponseDeliverTx_default_instance_);
}
inline ::suil::tmsp::types::ResponseDeliverTx* Response::mutable_deliver_tx() {
  if (!has_deliver_tx()) {
    clear_value();
    set_has_deliver_tx();
    value_.deliver_tx_ = CreateMaybeMessage< ::suil::tmsp::types::ResponseDeliverTx >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.Response.deliver_tx)
  return value_.deliver_tx_;
}

// .suil.tmsp.types.ResponseEndBlock end_block = 11;
inline bool Response::has_end_block() const {
  return value_case() == kEndBlock;
}
inline void Response::set_has_end_block() {
  _oneof_case_[0] = kEndBlock;
}
inline void Response::clear_end_block() {
  if (has_end_block()) {
    delete value_.end_block_;
    clear_has_value();
  }
}
inline ::suil::tmsp::types::ResponseEndBlock* Response::release_end_block() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.Response.end_block)
  if (has_end_block()) {
    clear_has_value();
      ::suil::tmsp::types::ResponseEndBlock* temp = value_.end_block_;
    value_.end_block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::suil::tmsp::types::ResponseEndBlock& Response::end_block() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Response.end_block)
  return has_end_block()
      ? *value_.end_block_
      : *reinterpret_cast< ::suil::tmsp::types::ResponseEndBlock*>(&::suil::tmsp::types::_ResponseEndBlock_default_instance_);
}
inline ::suil::tmsp::types::ResponseEndBlock* Response::mutable_end_block() {
  if (!has_end_block()) {
    clear_value();
    set_has_end_block();
    value_.end_block_ = CreateMaybeMessage< ::suil::tmsp::types::ResponseEndBlock >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.Response.end_block)
  return value_.end_block_;
}

// .suil.tmsp.types.ResponseCommit commit = 12;
inline bool Response::has_commit() const {
  return value_case() == kCommit;
}
inline void Response::set_has_commit() {
  _oneof_case_[0] = kCommit;
}
inline void Response::clear_commit() {
  if (has_commit()) {
    delete value_.commit_;
    clear_has_value();
  }
}
inline ::suil::tmsp::types::ResponseCommit* Response::release_commit() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.Response.commit)
  if (has_commit()) {
    clear_has_value();
      ::suil::tmsp::types::ResponseCommit* temp = value_.commit_;
    value_.commit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::suil::tmsp::types::ResponseCommit& Response::commit() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Response.commit)
  return has_commit()
      ? *value_.commit_
      : *reinterpret_cast< ::suil::tmsp::types::ResponseCommit*>(&::suil::tmsp::types::_ResponseCommit_default_instance_);
}
inline ::suil::tmsp::types::ResponseCommit* Response::mutable_commit() {
  if (!has_commit()) {
    clear_value();
    set_has_commit();
    value_.commit_ = CreateMaybeMessage< ::suil::tmsp::types::ResponseCommit >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.Response.commit)
  return value_.commit_;
}

inline bool Response::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Response::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline Response::ValueCase Response::value_case() const {
  return Response::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ResponseException

// string error = 1;
inline void ResponseException::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseException::error() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ResponseException.error)
  return error_.GetNoArena();
}
inline void ResponseException::set_error(const ::std::string& value) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.ResponseException.error)
}
#if LANG_CXX11
inline void ResponseException::set_error(::std::string&& value) {
  
  error_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.ResponseException.error)
}
#endif
inline void ResponseException::set_error(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.ResponseException.error)
}
inline void ResponseException::set_error(const char* value, size_t size) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.ResponseException.error)
}
inline ::std::string* ResponseException::mutable_error() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.ResponseException.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseException::release_error() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.ResponseException.error)
  
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseException::set_allocated_error(::std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.ResponseException.error)
}

// -------------------------------------------------------------------

// ResponseEcho

// string message = 1;
inline void ResponseEcho::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseEcho::message() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ResponseEcho.message)
  return message_.GetNoArena();
}
inline void ResponseEcho::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.ResponseEcho.message)
}
#if LANG_CXX11
inline void ResponseEcho::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.ResponseEcho.message)
}
#endif
inline void ResponseEcho::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.ResponseEcho.message)
}
inline void ResponseEcho::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.ResponseEcho.message)
}
inline ::std::string* ResponseEcho::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.ResponseEcho.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseEcho::release_message() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.ResponseEcho.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseEcho::set_allocated_message(::std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.ResponseEcho.message)
}

// -------------------------------------------------------------------

// ResponseFlush

// -------------------------------------------------------------------

// ResponseInfo

// string data = 1;
inline void ResponseInfo::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseInfo::data() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ResponseInfo.data)
  return data_.GetNoArena();
}
inline void ResponseInfo::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.ResponseInfo.data)
}
#if LANG_CXX11
inline void ResponseInfo::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.ResponseInfo.data)
}
#endif
inline void ResponseInfo::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.ResponseInfo.data)
}
inline void ResponseInfo::set_data(const char* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.ResponseInfo.data)
}
inline ::std::string* ResponseInfo::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.ResponseInfo.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseInfo::release_data() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.ResponseInfo.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseInfo::set_allocated_data(::std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.ResponseInfo.data)
}

// string version = 2;
inline void ResponseInfo::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseInfo::version() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ResponseInfo.version)
  return version_.GetNoArena();
}
inline void ResponseInfo::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.ResponseInfo.version)
}
#if LANG_CXX11
inline void ResponseInfo::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.ResponseInfo.version)
}
#endif
inline void ResponseInfo::set_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.ResponseInfo.version)
}
inline void ResponseInfo::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.ResponseInfo.version)
}
inline ::std::string* ResponseInfo::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.ResponseInfo.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseInfo::release_version() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.ResponseInfo.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseInfo::set_allocated_version(::std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.ResponseInfo.version)
}

// uint64 app_version = 3;
inline void ResponseInfo::clear_app_version() {
  app_version_ = PROTOBUF_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ResponseInfo::app_version() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ResponseInfo.app_version)
  return app_version_;
}
inline void ResponseInfo::set_app_version(::google::protobuf::uint64 value) {
  
  app_version_ = value;
  // @@protoc_insertion_point(field_set:suil.tmsp.types.ResponseInfo.app_version)
}

// int64 last_block_height = 4;
inline void ResponseInfo::clear_last_block_height() {
  last_block_height_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 ResponseInfo::last_block_height() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ResponseInfo.last_block_height)
  return last_block_height_;
}
inline void ResponseInfo::set_last_block_height(::google::protobuf::int64 value) {
  
  last_block_height_ = value;
  // @@protoc_insertion_point(field_set:suil.tmsp.types.ResponseInfo.last_block_height)
}

// bytes last_block_app_hash = 5;
inline void ResponseInfo::clear_last_block_app_hash() {
  last_block_app_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseInfo::last_block_app_hash() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ResponseInfo.last_block_app_hash)
  return last_block_app_hash_.GetNoArena();
}
inline void ResponseInfo::set_last_block_app_hash(const ::std::string& value) {
  
  last_block_app_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.ResponseInfo.last_block_app_hash)
}
#if LANG_CXX11
inline void ResponseInfo::set_last_block_app_hash(::std::string&& value) {
  
  last_block_app_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.ResponseInfo.last_block_app_hash)
}
#endif
inline void ResponseInfo::set_last_block_app_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  last_block_app_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.ResponseInfo.last_block_app_hash)
}
inline void ResponseInfo::set_last_block_app_hash(const void* value, size_t size) {
  
  last_block_app_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.ResponseInfo.last_block_app_hash)
}
inline ::std::string* ResponseInfo::mutable_last_block_app_hash() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.ResponseInfo.last_block_app_hash)
  return last_block_app_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseInfo::release_last_block_app_hash() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.ResponseInfo.last_block_app_hash)
  
  return last_block_app_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseInfo::set_allocated_last_block_app_hash(::std::string* last_block_app_hash) {
  if (last_block_app_hash != nullptr) {
    
  } else {
    
  }
  last_block_app_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), last_block_app_hash);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.ResponseInfo.last_block_app_hash)
}

// -------------------------------------------------------------------

// ResponseSetOption

// uint32 code = 1;
inline void ResponseSetOption::clear_code() {
  code_ = 0u;
}
inline ::google::protobuf::uint32 ResponseSetOption::code() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ResponseSetOption.code)
  return code_;
}
inline void ResponseSetOption::set_code(::google::protobuf::uint32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:suil.tmsp.types.ResponseSetOption.code)
}

// string log = 3;
inline void ResponseSetOption::clear_log() {
  log_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseSetOption::log() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ResponseSetOption.log)
  return log_.GetNoArena();
}
inline void ResponseSetOption::set_log(const ::std::string& value) {
  
  log_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.ResponseSetOption.log)
}
#if LANG_CXX11
inline void ResponseSetOption::set_log(::std::string&& value) {
  
  log_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.ResponseSetOption.log)
}
#endif
inline void ResponseSetOption::set_log(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  log_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.ResponseSetOption.log)
}
inline void ResponseSetOption::set_log(const char* value, size_t size) {
  
  log_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.ResponseSetOption.log)
}
inline ::std::string* ResponseSetOption::mutable_log() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.ResponseSetOption.log)
  return log_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseSetOption::release_log() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.ResponseSetOption.log)
  
  return log_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseSetOption::set_allocated_log(::std::string* log) {
  if (log != nullptr) {
    
  } else {
    
  }
  log_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), log);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.ResponseSetOption.log)
}

// string info = 4;
inline void ResponseSetOption::clear_info() {
  info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseSetOption::info() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ResponseSetOption.info)
  return info_.GetNoArena();
}
inline void ResponseSetOption::set_info(const ::std::string& value) {
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.ResponseSetOption.info)
}
#if LANG_CXX11
inline void ResponseSetOption::set_info(::std::string&& value) {
  
  info_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.ResponseSetOption.info)
}
#endif
inline void ResponseSetOption::set_info(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.ResponseSetOption.info)
}
inline void ResponseSetOption::set_info(const char* value, size_t size) {
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.ResponseSetOption.info)
}
inline ::std::string* ResponseSetOption::mutable_info() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.ResponseSetOption.info)
  return info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseSetOption::release_info() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.ResponseSetOption.info)
  
  return info_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseSetOption::set_allocated_info(::std::string* info) {
  if (info != nullptr) {
    
  } else {
    
  }
  info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), info);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.ResponseSetOption.info)
}

// -------------------------------------------------------------------

// ResponseInitChain

// .suil.tmsp.types.ConsensusParams consensus_params = 1;
inline bool ResponseInitChain::has_consensus_params() const {
  return this != internal_default_instance() && consensus_params_ != nullptr;
}
inline void ResponseInitChain::clear_consensus_params() {
  if (GetArenaNoVirtual() == nullptr && consensus_params_ != nullptr) {
    delete consensus_params_;
  }
  consensus_params_ = nullptr;
}
inline const ::suil::tmsp::types::ConsensusParams& ResponseInitChain::consensus_params() const {
  const ::suil::tmsp::types::ConsensusParams* p = consensus_params_;
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ResponseInitChain.consensus_params)
  return p != nullptr ? *p : *reinterpret_cast<const ::suil::tmsp::types::ConsensusParams*>(
      &::suil::tmsp::types::_ConsensusParams_default_instance_);
}
inline ::suil::tmsp::types::ConsensusParams* ResponseInitChain::release_consensus_params() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.ResponseInitChain.consensus_params)
  
  ::suil::tmsp::types::ConsensusParams* temp = consensus_params_;
  consensus_params_ = nullptr;
  return temp;
}
inline ::suil::tmsp::types::ConsensusParams* ResponseInitChain::mutable_consensus_params() {
  
  if (consensus_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::suil::tmsp::types::ConsensusParams>(GetArenaNoVirtual());
    consensus_params_ = p;
  }
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.ResponseInitChain.consensus_params)
  return consensus_params_;
}
inline void ResponseInitChain::set_allocated_consensus_params(::suil::tmsp::types::ConsensusParams* consensus_params) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete consensus_params_;
  }
  if (consensus_params) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      consensus_params = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, consensus_params, submessage_arena);
    }
    
  } else {
    
  }
  consensus_params_ = consensus_params;
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.ResponseInitChain.consensus_params)
}

// repeated .suil.tmsp.types.ValidatorUpdate validators = 2;
inline int ResponseInitChain::validators_size() const {
  return validators_.size();
}
inline void ResponseInitChain::clear_validators() {
  validators_.Clear();
}
inline ::suil::tmsp::types::ValidatorUpdate* ResponseInitChain::mutable_validators(int index) {
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.ResponseInitChain.validators)
  return validators_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::ValidatorUpdate >*
ResponseInitChain::mutable_validators() {
  // @@protoc_insertion_point(field_mutable_list:suil.tmsp.types.ResponseInitChain.validators)
  return &validators_;
}
inline const ::suil::tmsp::types::ValidatorUpdate& ResponseInitChain::validators(int index) const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ResponseInitChain.validators)
  return validators_.Get(index);
}
inline ::suil::tmsp::types::ValidatorUpdate* ResponseInitChain::add_validators() {
  // @@protoc_insertion_point(field_add:suil.tmsp.types.ResponseInitChain.validators)
  return validators_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::ValidatorUpdate >&
ResponseInitChain::validators() const {
  // @@protoc_insertion_point(field_list:suil.tmsp.types.ResponseInitChain.validators)
  return validators_;
}

// -------------------------------------------------------------------

// ResponseQuery

// uint32 code = 1;
inline void ResponseQuery::clear_code() {
  code_ = 0u;
}
inline ::google::protobuf::uint32 ResponseQuery::code() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ResponseQuery.code)
  return code_;
}
inline void ResponseQuery::set_code(::google::protobuf::uint32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:suil.tmsp.types.ResponseQuery.code)
}

// string log = 3;
inline void ResponseQuery::clear_log() {
  log_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseQuery::log() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ResponseQuery.log)
  return log_.GetNoArena();
}
inline void ResponseQuery::set_log(const ::std::string& value) {
  
  log_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.ResponseQuery.log)
}
#if LANG_CXX11
inline void ResponseQuery::set_log(::std::string&& value) {
  
  log_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.ResponseQuery.log)
}
#endif
inline void ResponseQuery::set_log(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  log_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.ResponseQuery.log)
}
inline void ResponseQuery::set_log(const char* value, size_t size) {
  
  log_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.ResponseQuery.log)
}
inline ::std::string* ResponseQuery::mutable_log() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.ResponseQuery.log)
  return log_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseQuery::release_log() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.ResponseQuery.log)
  
  return log_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseQuery::set_allocated_log(::std::string* log) {
  if (log != nullptr) {
    
  } else {
    
  }
  log_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), log);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.ResponseQuery.log)
}

// string info = 4;
inline void ResponseQuery::clear_info() {
  info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseQuery::info() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ResponseQuery.info)
  return info_.GetNoArena();
}
inline void ResponseQuery::set_info(const ::std::string& value) {
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.ResponseQuery.info)
}
#if LANG_CXX11
inline void ResponseQuery::set_info(::std::string&& value) {
  
  info_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.ResponseQuery.info)
}
#endif
inline void ResponseQuery::set_info(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.ResponseQuery.info)
}
inline void ResponseQuery::set_info(const char* value, size_t size) {
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.ResponseQuery.info)
}
inline ::std::string* ResponseQuery::mutable_info() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.ResponseQuery.info)
  return info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseQuery::release_info() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.ResponseQuery.info)
  
  return info_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseQuery::set_allocated_info(::std::string* info) {
  if (info != nullptr) {
    
  } else {
    
  }
  info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), info);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.ResponseQuery.info)
}

// int64 index = 5;
inline void ResponseQuery::clear_index() {
  index_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 ResponseQuery::index() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ResponseQuery.index)
  return index_;
}
inline void ResponseQuery::set_index(::google::protobuf::int64 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:suil.tmsp.types.ResponseQuery.index)
}

// bytes key = 6;
inline void ResponseQuery::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseQuery::key() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ResponseQuery.key)
  return key_.GetNoArena();
}
inline void ResponseQuery::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.ResponseQuery.key)
}
#if LANG_CXX11
inline void ResponseQuery::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.ResponseQuery.key)
}
#endif
inline void ResponseQuery::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.ResponseQuery.key)
}
inline void ResponseQuery::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.ResponseQuery.key)
}
inline ::std::string* ResponseQuery::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.ResponseQuery.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseQuery::release_key() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.ResponseQuery.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseQuery::set_allocated_key(::std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.ResponseQuery.key)
}

// bytes value = 7;
inline void ResponseQuery::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseQuery::value() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ResponseQuery.value)
  return value_.GetNoArena();
}
inline void ResponseQuery::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.ResponseQuery.value)
}
#if LANG_CXX11
inline void ResponseQuery::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.ResponseQuery.value)
}
#endif
inline void ResponseQuery::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.ResponseQuery.value)
}
inline void ResponseQuery::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.ResponseQuery.value)
}
inline ::std::string* ResponseQuery::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.ResponseQuery.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseQuery::release_value() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.ResponseQuery.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseQuery::set_allocated_value(::std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.ResponseQuery.value)
}

// .suil.tmsp.types.Proof proof = 8;
inline bool ResponseQuery::has_proof() const {
  return this != internal_default_instance() && proof_ != nullptr;
}
inline void ResponseQuery::clear_proof() {
  if (GetArenaNoVirtual() == nullptr && proof_ != nullptr) {
    delete proof_;
  }
  proof_ = nullptr;
}
inline const ::suil::tmsp::types::Proof& ResponseQuery::proof() const {
  const ::suil::tmsp::types::Proof* p = proof_;
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ResponseQuery.proof)
  return p != nullptr ? *p : *reinterpret_cast<const ::suil::tmsp::types::Proof*>(
      &::suil::tmsp::types::_Proof_default_instance_);
}
inline ::suil::tmsp::types::Proof* ResponseQuery::release_proof() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.ResponseQuery.proof)
  
  ::suil::tmsp::types::Proof* temp = proof_;
  proof_ = nullptr;
  return temp;
}
inline ::suil::tmsp::types::Proof* ResponseQuery::mutable_proof() {
  
  if (proof_ == nullptr) {
    auto* p = CreateMaybeMessage<::suil::tmsp::types::Proof>(GetArenaNoVirtual());
    proof_ = p;
  }
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.ResponseQuery.proof)
  return proof_;
}
inline void ResponseQuery::set_allocated_proof(::suil::tmsp::types::Proof* proof) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete proof_;
  }
  if (proof) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      proof = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, proof, submessage_arena);
    }
    
  } else {
    
  }
  proof_ = proof;
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.ResponseQuery.proof)
}

// int64 height = 9;
inline void ResponseQuery::clear_height() {
  height_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 ResponseQuery::height() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ResponseQuery.height)
  return height_;
}
inline void ResponseQuery::set_height(::google::protobuf::int64 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:suil.tmsp.types.ResponseQuery.height)
}

// string codespace = 10;
inline void ResponseQuery::clear_codespace() {
  codespace_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseQuery::codespace() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ResponseQuery.codespace)
  return codespace_.GetNoArena();
}
inline void ResponseQuery::set_codespace(const ::std::string& value) {
  
  codespace_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.ResponseQuery.codespace)
}
#if LANG_CXX11
inline void ResponseQuery::set_codespace(::std::string&& value) {
  
  codespace_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.ResponseQuery.codespace)
}
#endif
inline void ResponseQuery::set_codespace(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  codespace_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.ResponseQuery.codespace)
}
inline void ResponseQuery::set_codespace(const char* value, size_t size) {
  
  codespace_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.ResponseQuery.codespace)
}
inline ::std::string* ResponseQuery::mutable_codespace() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.ResponseQuery.codespace)
  return codespace_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseQuery::release_codespace() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.ResponseQuery.codespace)
  
  return codespace_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseQuery::set_allocated_codespace(::std::string* codespace) {
  if (codespace != nullptr) {
    
  } else {
    
  }
  codespace_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), codespace);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.ResponseQuery.codespace)
}

// -------------------------------------------------------------------

// ResponseBeginBlock

// repeated .suil.tmsp.types.KVPair tags = 1;
inline int ResponseBeginBlock::tags_size() const {
  return tags_.size();
}
inline void ResponseBeginBlock::clear_tags() {
  tags_.Clear();
}
inline ::suil::tmsp::types::KVPair* ResponseBeginBlock::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.ResponseBeginBlock.tags)
  return tags_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::KVPair >*
ResponseBeginBlock::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:suil.tmsp.types.ResponseBeginBlock.tags)
  return &tags_;
}
inline const ::suil::tmsp::types::KVPair& ResponseBeginBlock::tags(int index) const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ResponseBeginBlock.tags)
  return tags_.Get(index);
}
inline ::suil::tmsp::types::KVPair* ResponseBeginBlock::add_tags() {
  // @@protoc_insertion_point(field_add:suil.tmsp.types.ResponseBeginBlock.tags)
  return tags_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::KVPair >&
ResponseBeginBlock::tags() const {
  // @@protoc_insertion_point(field_list:suil.tmsp.types.ResponseBeginBlock.tags)
  return tags_;
}

// -------------------------------------------------------------------

// ResponseCheckTx

// uint32 code = 1;
inline void ResponseCheckTx::clear_code() {
  code_ = 0u;
}
inline ::google::protobuf::uint32 ResponseCheckTx::code() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ResponseCheckTx.code)
  return code_;
}
inline void ResponseCheckTx::set_code(::google::protobuf::uint32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:suil.tmsp.types.ResponseCheckTx.code)
}

// bytes data = 2;
inline void ResponseCheckTx::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseCheckTx::data() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ResponseCheckTx.data)
  return data_.GetNoArena();
}
inline void ResponseCheckTx::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.ResponseCheckTx.data)
}
#if LANG_CXX11
inline void ResponseCheckTx::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.ResponseCheckTx.data)
}
#endif
inline void ResponseCheckTx::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.ResponseCheckTx.data)
}
inline void ResponseCheckTx::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.ResponseCheckTx.data)
}
inline ::std::string* ResponseCheckTx::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.ResponseCheckTx.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseCheckTx::release_data() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.ResponseCheckTx.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseCheckTx::set_allocated_data(::std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.ResponseCheckTx.data)
}

// string log = 3;
inline void ResponseCheckTx::clear_log() {
  log_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseCheckTx::log() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ResponseCheckTx.log)
  return log_.GetNoArena();
}
inline void ResponseCheckTx::set_log(const ::std::string& value) {
  
  log_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.ResponseCheckTx.log)
}
#if LANG_CXX11
inline void ResponseCheckTx::set_log(::std::string&& value) {
  
  log_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.ResponseCheckTx.log)
}
#endif
inline void ResponseCheckTx::set_log(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  log_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.ResponseCheckTx.log)
}
inline void ResponseCheckTx::set_log(const char* value, size_t size) {
  
  log_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.ResponseCheckTx.log)
}
inline ::std::string* ResponseCheckTx::mutable_log() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.ResponseCheckTx.log)
  return log_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseCheckTx::release_log() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.ResponseCheckTx.log)
  
  return log_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseCheckTx::set_allocated_log(::std::string* log) {
  if (log != nullptr) {
    
  } else {
    
  }
  log_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), log);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.ResponseCheckTx.log)
}

// string info = 4;
inline void ResponseCheckTx::clear_info() {
  info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseCheckTx::info() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ResponseCheckTx.info)
  return info_.GetNoArena();
}
inline void ResponseCheckTx::set_info(const ::std::string& value) {
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.ResponseCheckTx.info)
}
#if LANG_CXX11
inline void ResponseCheckTx::set_info(::std::string&& value) {
  
  info_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.ResponseCheckTx.info)
}
#endif
inline void ResponseCheckTx::set_info(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.ResponseCheckTx.info)
}
inline void ResponseCheckTx::set_info(const char* value, size_t size) {
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.ResponseCheckTx.info)
}
inline ::std::string* ResponseCheckTx::mutable_info() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.ResponseCheckTx.info)
  return info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseCheckTx::release_info() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.ResponseCheckTx.info)
  
  return info_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseCheckTx::set_allocated_info(::std::string* info) {
  if (info != nullptr) {
    
  } else {
    
  }
  info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), info);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.ResponseCheckTx.info)
}

// int64 gas_wanted = 5;
inline void ResponseCheckTx::clear_gas_wanted() {
  gas_wanted_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 ResponseCheckTx::gas_wanted() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ResponseCheckTx.gas_wanted)
  return gas_wanted_;
}
inline void ResponseCheckTx::set_gas_wanted(::google::protobuf::int64 value) {
  
  gas_wanted_ = value;
  // @@protoc_insertion_point(field_set:suil.tmsp.types.ResponseCheckTx.gas_wanted)
}

// int64 gas_used = 6;
inline void ResponseCheckTx::clear_gas_used() {
  gas_used_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 ResponseCheckTx::gas_used() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ResponseCheckTx.gas_used)
  return gas_used_;
}
inline void ResponseCheckTx::set_gas_used(::google::protobuf::int64 value) {
  
  gas_used_ = value;
  // @@protoc_insertion_point(field_set:suil.tmsp.types.ResponseCheckTx.gas_used)
}

// repeated .suil.tmsp.types.KVPair tags = 7;
inline int ResponseCheckTx::tags_size() const {
  return tags_.size();
}
inline void ResponseCheckTx::clear_tags() {
  tags_.Clear();
}
inline ::suil::tmsp::types::KVPair* ResponseCheckTx::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.ResponseCheckTx.tags)
  return tags_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::KVPair >*
ResponseCheckTx::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:suil.tmsp.types.ResponseCheckTx.tags)
  return &tags_;
}
inline const ::suil::tmsp::types::KVPair& ResponseCheckTx::tags(int index) const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ResponseCheckTx.tags)
  return tags_.Get(index);
}
inline ::suil::tmsp::types::KVPair* ResponseCheckTx::add_tags() {
  // @@protoc_insertion_point(field_add:suil.tmsp.types.ResponseCheckTx.tags)
  return tags_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::KVPair >&
ResponseCheckTx::tags() const {
  // @@protoc_insertion_point(field_list:suil.tmsp.types.ResponseCheckTx.tags)
  return tags_;
}

// string codespace = 8;
inline void ResponseCheckTx::clear_codespace() {
  codespace_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseCheckTx::codespace() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ResponseCheckTx.codespace)
  return codespace_.GetNoArena();
}
inline void ResponseCheckTx::set_codespace(const ::std::string& value) {
  
  codespace_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.ResponseCheckTx.codespace)
}
#if LANG_CXX11
inline void ResponseCheckTx::set_codespace(::std::string&& value) {
  
  codespace_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.ResponseCheckTx.codespace)
}
#endif
inline void ResponseCheckTx::set_codespace(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  codespace_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.ResponseCheckTx.codespace)
}
inline void ResponseCheckTx::set_codespace(const char* value, size_t size) {
  
  codespace_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.ResponseCheckTx.codespace)
}
inline ::std::string* ResponseCheckTx::mutable_codespace() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.ResponseCheckTx.codespace)
  return codespace_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseCheckTx::release_codespace() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.ResponseCheckTx.codespace)
  
  return codespace_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseCheckTx::set_allocated_codespace(::std::string* codespace) {
  if (codespace != nullptr) {
    
  } else {
    
  }
  codespace_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), codespace);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.ResponseCheckTx.codespace)
}

// -------------------------------------------------------------------

// ResponseDeliverTx

// uint32 code = 1;
inline void ResponseDeliverTx::clear_code() {
  code_ = 0u;
}
inline ::google::protobuf::uint32 ResponseDeliverTx::code() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ResponseDeliverTx.code)
  return code_;
}
inline void ResponseDeliverTx::set_code(::google::protobuf::uint32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:suil.tmsp.types.ResponseDeliverTx.code)
}

// bytes data = 2;
inline void ResponseDeliverTx::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseDeliverTx::data() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ResponseDeliverTx.data)
  return data_.GetNoArena();
}
inline void ResponseDeliverTx::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.ResponseDeliverTx.data)
}
#if LANG_CXX11
inline void ResponseDeliverTx::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.ResponseDeliverTx.data)
}
#endif
inline void ResponseDeliverTx::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.ResponseDeliverTx.data)
}
inline void ResponseDeliverTx::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.ResponseDeliverTx.data)
}
inline ::std::string* ResponseDeliverTx::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.ResponseDeliverTx.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseDeliverTx::release_data() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.ResponseDeliverTx.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseDeliverTx::set_allocated_data(::std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.ResponseDeliverTx.data)
}

// string log = 3;
inline void ResponseDeliverTx::clear_log() {
  log_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseDeliverTx::log() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ResponseDeliverTx.log)
  return log_.GetNoArena();
}
inline void ResponseDeliverTx::set_log(const ::std::string& value) {
  
  log_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.ResponseDeliverTx.log)
}
#if LANG_CXX11
inline void ResponseDeliverTx::set_log(::std::string&& value) {
  
  log_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.ResponseDeliverTx.log)
}
#endif
inline void ResponseDeliverTx::set_log(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  log_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.ResponseDeliverTx.log)
}
inline void ResponseDeliverTx::set_log(const char* value, size_t size) {
  
  log_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.ResponseDeliverTx.log)
}
inline ::std::string* ResponseDeliverTx::mutable_log() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.ResponseDeliverTx.log)
  return log_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseDeliverTx::release_log() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.ResponseDeliverTx.log)
  
  return log_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseDeliverTx::set_allocated_log(::std::string* log) {
  if (log != nullptr) {
    
  } else {
    
  }
  log_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), log);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.ResponseDeliverTx.log)
}

// string info = 4;
inline void ResponseDeliverTx::clear_info() {
  info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseDeliverTx::info() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ResponseDeliverTx.info)
  return info_.GetNoArena();
}
inline void ResponseDeliverTx::set_info(const ::std::string& value) {
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.ResponseDeliverTx.info)
}
#if LANG_CXX11
inline void ResponseDeliverTx::set_info(::std::string&& value) {
  
  info_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.ResponseDeliverTx.info)
}
#endif
inline void ResponseDeliverTx::set_info(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.ResponseDeliverTx.info)
}
inline void ResponseDeliverTx::set_info(const char* value, size_t size) {
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.ResponseDeliverTx.info)
}
inline ::std::string* ResponseDeliverTx::mutable_info() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.ResponseDeliverTx.info)
  return info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseDeliverTx::release_info() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.ResponseDeliverTx.info)
  
  return info_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseDeliverTx::set_allocated_info(::std::string* info) {
  if (info != nullptr) {
    
  } else {
    
  }
  info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), info);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.ResponseDeliverTx.info)
}

// int64 gas_wanted = 5;
inline void ResponseDeliverTx::clear_gas_wanted() {
  gas_wanted_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 ResponseDeliverTx::gas_wanted() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ResponseDeliverTx.gas_wanted)
  return gas_wanted_;
}
inline void ResponseDeliverTx::set_gas_wanted(::google::protobuf::int64 value) {
  
  gas_wanted_ = value;
  // @@protoc_insertion_point(field_set:suil.tmsp.types.ResponseDeliverTx.gas_wanted)
}

// int64 gas_used = 6;
inline void ResponseDeliverTx::clear_gas_used() {
  gas_used_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 ResponseDeliverTx::gas_used() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ResponseDeliverTx.gas_used)
  return gas_used_;
}
inline void ResponseDeliverTx::set_gas_used(::google::protobuf::int64 value) {
  
  gas_used_ = value;
  // @@protoc_insertion_point(field_set:suil.tmsp.types.ResponseDeliverTx.gas_used)
}

// repeated .suil.tmsp.types.KVPair tags = 7;
inline int ResponseDeliverTx::tags_size() const {
  return tags_.size();
}
inline void ResponseDeliverTx::clear_tags() {
  tags_.Clear();
}
inline ::suil::tmsp::types::KVPair* ResponseDeliverTx::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.ResponseDeliverTx.tags)
  return tags_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::KVPair >*
ResponseDeliverTx::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:suil.tmsp.types.ResponseDeliverTx.tags)
  return &tags_;
}
inline const ::suil::tmsp::types::KVPair& ResponseDeliverTx::tags(int index) const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ResponseDeliverTx.tags)
  return tags_.Get(index);
}
inline ::suil::tmsp::types::KVPair* ResponseDeliverTx::add_tags() {
  // @@protoc_insertion_point(field_add:suil.tmsp.types.ResponseDeliverTx.tags)
  return tags_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::KVPair >&
ResponseDeliverTx::tags() const {
  // @@protoc_insertion_point(field_list:suil.tmsp.types.ResponseDeliverTx.tags)
  return tags_;
}

// string codespace = 8;
inline void ResponseDeliverTx::clear_codespace() {
  codespace_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseDeliverTx::codespace() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ResponseDeliverTx.codespace)
  return codespace_.GetNoArena();
}
inline void ResponseDeliverTx::set_codespace(const ::std::string& value) {
  
  codespace_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.ResponseDeliverTx.codespace)
}
#if LANG_CXX11
inline void ResponseDeliverTx::set_codespace(::std::string&& value) {
  
  codespace_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.ResponseDeliverTx.codespace)
}
#endif
inline void ResponseDeliverTx::set_codespace(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  codespace_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.ResponseDeliverTx.codespace)
}
inline void ResponseDeliverTx::set_codespace(const char* value, size_t size) {
  
  codespace_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.ResponseDeliverTx.codespace)
}
inline ::std::string* ResponseDeliverTx::mutable_codespace() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.ResponseDeliverTx.codespace)
  return codespace_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseDeliverTx::release_codespace() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.ResponseDeliverTx.codespace)
  
  return codespace_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseDeliverTx::set_allocated_codespace(::std::string* codespace) {
  if (codespace != nullptr) {
    
  } else {
    
  }
  codespace_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), codespace);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.ResponseDeliverTx.codespace)
}

// -------------------------------------------------------------------

// ResponseEndBlock

// repeated .suil.tmsp.types.ValidatorUpdate validator_updates = 1;
inline int ResponseEndBlock::validator_updates_size() const {
  return validator_updates_.size();
}
inline void ResponseEndBlock::clear_validator_updates() {
  validator_updates_.Clear();
}
inline ::suil::tmsp::types::ValidatorUpdate* ResponseEndBlock::mutable_validator_updates(int index) {
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.ResponseEndBlock.validator_updates)
  return validator_updates_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::ValidatorUpdate >*
ResponseEndBlock::mutable_validator_updates() {
  // @@protoc_insertion_point(field_mutable_list:suil.tmsp.types.ResponseEndBlock.validator_updates)
  return &validator_updates_;
}
inline const ::suil::tmsp::types::ValidatorUpdate& ResponseEndBlock::validator_updates(int index) const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ResponseEndBlock.validator_updates)
  return validator_updates_.Get(index);
}
inline ::suil::tmsp::types::ValidatorUpdate* ResponseEndBlock::add_validator_updates() {
  // @@protoc_insertion_point(field_add:suil.tmsp.types.ResponseEndBlock.validator_updates)
  return validator_updates_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::ValidatorUpdate >&
ResponseEndBlock::validator_updates() const {
  // @@protoc_insertion_point(field_list:suil.tmsp.types.ResponseEndBlock.validator_updates)
  return validator_updates_;
}

// .suil.tmsp.types.ConsensusParams consensus_param_updates = 2;
inline bool ResponseEndBlock::has_consensus_param_updates() const {
  return this != internal_default_instance() && consensus_param_updates_ != nullptr;
}
inline void ResponseEndBlock::clear_consensus_param_updates() {
  if (GetArenaNoVirtual() == nullptr && consensus_param_updates_ != nullptr) {
    delete consensus_param_updates_;
  }
  consensus_param_updates_ = nullptr;
}
inline const ::suil::tmsp::types::ConsensusParams& ResponseEndBlock::consensus_param_updates() const {
  const ::suil::tmsp::types::ConsensusParams* p = consensus_param_updates_;
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ResponseEndBlock.consensus_param_updates)
  return p != nullptr ? *p : *reinterpret_cast<const ::suil::tmsp::types::ConsensusParams*>(
      &::suil::tmsp::types::_ConsensusParams_default_instance_);
}
inline ::suil::tmsp::types::ConsensusParams* ResponseEndBlock::release_consensus_param_updates() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.ResponseEndBlock.consensus_param_updates)
  
  ::suil::tmsp::types::ConsensusParams* temp = consensus_param_updates_;
  consensus_param_updates_ = nullptr;
  return temp;
}
inline ::suil::tmsp::types::ConsensusParams* ResponseEndBlock::mutable_consensus_param_updates() {
  
  if (consensus_param_updates_ == nullptr) {
    auto* p = CreateMaybeMessage<::suil::tmsp::types::ConsensusParams>(GetArenaNoVirtual());
    consensus_param_updates_ = p;
  }
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.ResponseEndBlock.consensus_param_updates)
  return consensus_param_updates_;
}
inline void ResponseEndBlock::set_allocated_consensus_param_updates(::suil::tmsp::types::ConsensusParams* consensus_param_updates) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete consensus_param_updates_;
  }
  if (consensus_param_updates) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      consensus_param_updates = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, consensus_param_updates, submessage_arena);
    }
    
  } else {
    
  }
  consensus_param_updates_ = consensus_param_updates;
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.ResponseEndBlock.consensus_param_updates)
}

// repeated .suil.tmsp.types.KVPair tags = 3;
inline int ResponseEndBlock::tags_size() const {
  return tags_.size();
}
inline void ResponseEndBlock::clear_tags() {
  tags_.Clear();
}
inline ::suil::tmsp::types::KVPair* ResponseEndBlock::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.ResponseEndBlock.tags)
  return tags_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::KVPair >*
ResponseEndBlock::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:suil.tmsp.types.ResponseEndBlock.tags)
  return &tags_;
}
inline const ::suil::tmsp::types::KVPair& ResponseEndBlock::tags(int index) const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ResponseEndBlock.tags)
  return tags_.Get(index);
}
inline ::suil::tmsp::types::KVPair* ResponseEndBlock::add_tags() {
  // @@protoc_insertion_point(field_add:suil.tmsp.types.ResponseEndBlock.tags)
  return tags_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::KVPair >&
ResponseEndBlock::tags() const {
  // @@protoc_insertion_point(field_list:suil.tmsp.types.ResponseEndBlock.tags)
  return tags_;
}

// -------------------------------------------------------------------

// ResponseCommit

// bytes data = 2;
inline void ResponseCommit::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseCommit::data() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ResponseCommit.data)
  return data_.GetNoArena();
}
inline void ResponseCommit::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.ResponseCommit.data)
}
#if LANG_CXX11
inline void ResponseCommit::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.ResponseCommit.data)
}
#endif
inline void ResponseCommit::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.ResponseCommit.data)
}
inline void ResponseCommit::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.ResponseCommit.data)
}
inline ::std::string* ResponseCommit::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.ResponseCommit.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseCommit::release_data() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.ResponseCommit.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseCommit::set_allocated_data(::std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.ResponseCommit.data)
}

// -------------------------------------------------------------------

// ConsensusParams

// .suil.tmsp.types.BlockSizeParams block_size = 1;
inline bool ConsensusParams::has_block_size() const {
  return this != internal_default_instance() && block_size_ != nullptr;
}
inline void ConsensusParams::clear_block_size() {
  if (GetArenaNoVirtual() == nullptr && block_size_ != nullptr) {
    delete block_size_;
  }
  block_size_ = nullptr;
}
inline const ::suil::tmsp::types::BlockSizeParams& ConsensusParams::block_size() const {
  const ::suil::tmsp::types::BlockSizeParams* p = block_size_;
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ConsensusParams.block_size)
  return p != nullptr ? *p : *reinterpret_cast<const ::suil::tmsp::types::BlockSizeParams*>(
      &::suil::tmsp::types::_BlockSizeParams_default_instance_);
}
inline ::suil::tmsp::types::BlockSizeParams* ConsensusParams::release_block_size() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.ConsensusParams.block_size)
  
  ::suil::tmsp::types::BlockSizeParams* temp = block_size_;
  block_size_ = nullptr;
  return temp;
}
inline ::suil::tmsp::types::BlockSizeParams* ConsensusParams::mutable_block_size() {
  
  if (block_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::suil::tmsp::types::BlockSizeParams>(GetArenaNoVirtual());
    block_size_ = p;
  }
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.ConsensusParams.block_size)
  return block_size_;
}
inline void ConsensusParams::set_allocated_block_size(::suil::tmsp::types::BlockSizeParams* block_size) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete block_size_;
  }
  if (block_size) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      block_size = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, block_size, submessage_arena);
    }
    
  } else {
    
  }
  block_size_ = block_size;
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.ConsensusParams.block_size)
}

// .suil.tmsp.types.EvidenceParams evidence = 2;
inline bool ConsensusParams::has_evidence() const {
  return this != internal_default_instance() && evidence_ != nullptr;
}
inline void ConsensusParams::clear_evidence() {
  if (GetArenaNoVirtual() == nullptr && evidence_ != nullptr) {
    delete evidence_;
  }
  evidence_ = nullptr;
}
inline const ::suil::tmsp::types::EvidenceParams& ConsensusParams::evidence() const {
  const ::suil::tmsp::types::EvidenceParams* p = evidence_;
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ConsensusParams.evidence)
  return p != nullptr ? *p : *reinterpret_cast<const ::suil::tmsp::types::EvidenceParams*>(
      &::suil::tmsp::types::_EvidenceParams_default_instance_);
}
inline ::suil::tmsp::types::EvidenceParams* ConsensusParams::release_evidence() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.ConsensusParams.evidence)
  
  ::suil::tmsp::types::EvidenceParams* temp = evidence_;
  evidence_ = nullptr;
  return temp;
}
inline ::suil::tmsp::types::EvidenceParams* ConsensusParams::mutable_evidence() {
  
  if (evidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::suil::tmsp::types::EvidenceParams>(GetArenaNoVirtual());
    evidence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.ConsensusParams.evidence)
  return evidence_;
}
inline void ConsensusParams::set_allocated_evidence(::suil::tmsp::types::EvidenceParams* evidence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete evidence_;
  }
  if (evidence) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      evidence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, evidence, submessage_arena);
    }
    
  } else {
    
  }
  evidence_ = evidence;
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.ConsensusParams.evidence)
}

// .suil.tmsp.types.ValidatorParams validator = 3;
inline bool ConsensusParams::has_validator() const {
  return this != internal_default_instance() && validator_ != nullptr;
}
inline void ConsensusParams::clear_validator() {
  if (GetArenaNoVirtual() == nullptr && validator_ != nullptr) {
    delete validator_;
  }
  validator_ = nullptr;
}
inline const ::suil::tmsp::types::ValidatorParams& ConsensusParams::validator() const {
  const ::suil::tmsp::types::ValidatorParams* p = validator_;
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ConsensusParams.validator)
  return p != nullptr ? *p : *reinterpret_cast<const ::suil::tmsp::types::ValidatorParams*>(
      &::suil::tmsp::types::_ValidatorParams_default_instance_);
}
inline ::suil::tmsp::types::ValidatorParams* ConsensusParams::release_validator() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.ConsensusParams.validator)
  
  ::suil::tmsp::types::ValidatorParams* temp = validator_;
  validator_ = nullptr;
  return temp;
}
inline ::suil::tmsp::types::ValidatorParams* ConsensusParams::mutable_validator() {
  
  if (validator_ == nullptr) {
    auto* p = CreateMaybeMessage<::suil::tmsp::types::ValidatorParams>(GetArenaNoVirtual());
    validator_ = p;
  }
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.ConsensusParams.validator)
  return validator_;
}
inline void ConsensusParams::set_allocated_validator(::suil::tmsp::types::ValidatorParams* validator) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete validator_;
  }
  if (validator) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      validator = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, validator, submessage_arena);
    }
    
  } else {
    
  }
  validator_ = validator;
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.ConsensusParams.validator)
}

// -------------------------------------------------------------------

// BlockSizeParams

// int64 max_bytes = 1;
inline void BlockSizeParams::clear_max_bytes() {
  max_bytes_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 BlockSizeParams::max_bytes() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.BlockSizeParams.max_bytes)
  return max_bytes_;
}
inline void BlockSizeParams::set_max_bytes(::google::protobuf::int64 value) {
  
  max_bytes_ = value;
  // @@protoc_insertion_point(field_set:suil.tmsp.types.BlockSizeParams.max_bytes)
}

// int64 max_gas = 2;
inline void BlockSizeParams::clear_max_gas() {
  max_gas_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 BlockSizeParams::max_gas() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.BlockSizeParams.max_gas)
  return max_gas_;
}
inline void BlockSizeParams::set_max_gas(::google::protobuf::int64 value) {
  
  max_gas_ = value;
  // @@protoc_insertion_point(field_set:suil.tmsp.types.BlockSizeParams.max_gas)
}

// -------------------------------------------------------------------

// EvidenceParams

// int64 max_age = 1;
inline void EvidenceParams::clear_max_age() {
  max_age_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 EvidenceParams::max_age() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.EvidenceParams.max_age)
  return max_age_;
}
inline void EvidenceParams::set_max_age(::google::protobuf::int64 value) {
  
  max_age_ = value;
  // @@protoc_insertion_point(field_set:suil.tmsp.types.EvidenceParams.max_age)
}

// -------------------------------------------------------------------

// ValidatorParams

// repeated string pub_key_types = 1;
inline int ValidatorParams::pub_key_types_size() const {
  return pub_key_types_.size();
}
inline void ValidatorParams::clear_pub_key_types() {
  pub_key_types_.Clear();
}
inline const ::std::string& ValidatorParams::pub_key_types(int index) const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ValidatorParams.pub_key_types)
  return pub_key_types_.Get(index);
}
inline ::std::string* ValidatorParams::mutable_pub_key_types(int index) {
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.ValidatorParams.pub_key_types)
  return pub_key_types_.Mutable(index);
}
inline void ValidatorParams::set_pub_key_types(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:suil.tmsp.types.ValidatorParams.pub_key_types)
  pub_key_types_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ValidatorParams::set_pub_key_types(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:suil.tmsp.types.ValidatorParams.pub_key_types)
  pub_key_types_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ValidatorParams::set_pub_key_types(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  pub_key_types_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.ValidatorParams.pub_key_types)
}
inline void ValidatorParams::set_pub_key_types(int index, const char* value, size_t size) {
  pub_key_types_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.ValidatorParams.pub_key_types)
}
inline ::std::string* ValidatorParams::add_pub_key_types() {
  // @@protoc_insertion_point(field_add_mutable:suil.tmsp.types.ValidatorParams.pub_key_types)
  return pub_key_types_.Add();
}
inline void ValidatorParams::add_pub_key_types(const ::std::string& value) {
  pub_key_types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:suil.tmsp.types.ValidatorParams.pub_key_types)
}
#if LANG_CXX11
inline void ValidatorParams::add_pub_key_types(::std::string&& value) {
  pub_key_types_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:suil.tmsp.types.ValidatorParams.pub_key_types)
}
#endif
inline void ValidatorParams::add_pub_key_types(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  pub_key_types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:suil.tmsp.types.ValidatorParams.pub_key_types)
}
inline void ValidatorParams::add_pub_key_types(const char* value, size_t size) {
  pub_key_types_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:suil.tmsp.types.ValidatorParams.pub_key_types)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
ValidatorParams::pub_key_types() const {
  // @@protoc_insertion_point(field_list:suil.tmsp.types.ValidatorParams.pub_key_types)
  return pub_key_types_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
ValidatorParams::mutable_pub_key_types() {
  // @@protoc_insertion_point(field_mutable_list:suil.tmsp.types.ValidatorParams.pub_key_types)
  return &pub_key_types_;
}

// -------------------------------------------------------------------

// LastCommitInfo

// int32 round = 1;
inline void LastCommitInfo::clear_round() {
  round_ = 0;
}
inline ::google::protobuf::int32 LastCommitInfo::round() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.LastCommitInfo.round)
  return round_;
}
inline void LastCommitInfo::set_round(::google::protobuf::int32 value) {
  
  round_ = value;
  // @@protoc_insertion_point(field_set:suil.tmsp.types.LastCommitInfo.round)
}

// repeated .suil.tmsp.types.VoteInfo votes = 2;
inline int LastCommitInfo::votes_size() const {
  return votes_.size();
}
inline void LastCommitInfo::clear_votes() {
  votes_.Clear();
}
inline ::suil::tmsp::types::VoteInfo* LastCommitInfo::mutable_votes(int index) {
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.LastCommitInfo.votes)
  return votes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::VoteInfo >*
LastCommitInfo::mutable_votes() {
  // @@protoc_insertion_point(field_mutable_list:suil.tmsp.types.LastCommitInfo.votes)
  return &votes_;
}
inline const ::suil::tmsp::types::VoteInfo& LastCommitInfo::votes(int index) const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.LastCommitInfo.votes)
  return votes_.Get(index);
}
inline ::suil::tmsp::types::VoteInfo* LastCommitInfo::add_votes() {
  // @@protoc_insertion_point(field_add:suil.tmsp.types.LastCommitInfo.votes)
  return votes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::suil::tmsp::types::VoteInfo >&
LastCommitInfo::votes() const {
  // @@protoc_insertion_point(field_list:suil.tmsp.types.LastCommitInfo.votes)
  return votes_;
}

// -------------------------------------------------------------------

// Header

// .suil.tmsp.types.Version version = 1;
inline bool Header::has_version() const {
  return this != internal_default_instance() && version_ != nullptr;
}
inline void Header::clear_version() {
  if (GetArenaNoVirtual() == nullptr && version_ != nullptr) {
    delete version_;
  }
  version_ = nullptr;
}
inline const ::suil::tmsp::types::Version& Header::version() const {
  const ::suil::tmsp::types::Version* p = version_;
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Header.version)
  return p != nullptr ? *p : *reinterpret_cast<const ::suil::tmsp::types::Version*>(
      &::suil::tmsp::types::_Version_default_instance_);
}
inline ::suil::tmsp::types::Version* Header::release_version() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.Header.version)
  
  ::suil::tmsp::types::Version* temp = version_;
  version_ = nullptr;
  return temp;
}
inline ::suil::tmsp::types::Version* Header::mutable_version() {
  
  if (version_ == nullptr) {
    auto* p = CreateMaybeMessage<::suil::tmsp::types::Version>(GetArenaNoVirtual());
    version_ = p;
  }
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.Header.version)
  return version_;
}
inline void Header::set_allocated_version(::suil::tmsp::types::Version* version) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete version_;
  }
  if (version) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      version = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, version, submessage_arena);
    }
    
  } else {
    
  }
  version_ = version;
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.Header.version)
}

// string chain_id = 2;
inline void Header::clear_chain_id() {
  chain_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Header::chain_id() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Header.chain_id)
  return chain_id_.GetNoArena();
}
inline void Header::set_chain_id(const ::std::string& value) {
  
  chain_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.Header.chain_id)
}
#if LANG_CXX11
inline void Header::set_chain_id(::std::string&& value) {
  
  chain_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.Header.chain_id)
}
#endif
inline void Header::set_chain_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  chain_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.Header.chain_id)
}
inline void Header::set_chain_id(const char* value, size_t size) {
  
  chain_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.Header.chain_id)
}
inline ::std::string* Header::mutable_chain_id() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.Header.chain_id)
  return chain_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_chain_id() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.Header.chain_id)
  
  return chain_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_chain_id(::std::string* chain_id) {
  if (chain_id != nullptr) {
    
  } else {
    
  }
  chain_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), chain_id);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.Header.chain_id)
}

// int64 height = 3;
inline void Header::clear_height() {
  height_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 Header::height() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Header.height)
  return height_;
}
inline void Header::set_height(::google::protobuf::int64 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:suil.tmsp.types.Header.height)
}

// .suil.tmsp.types.Timestamp time = 4;
inline bool Header::has_time() const {
  return this != internal_default_instance() && time_ != nullptr;
}
inline void Header::clear_time() {
  if (GetArenaNoVirtual() == nullptr && time_ != nullptr) {
    delete time_;
  }
  time_ = nullptr;
}
inline const ::suil::tmsp::types::Timestamp& Header::time() const {
  const ::suil::tmsp::types::Timestamp* p = time_;
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Header.time)
  return p != nullptr ? *p : *reinterpret_cast<const ::suil::tmsp::types::Timestamp*>(
      &::suil::tmsp::types::_Timestamp_default_instance_);
}
inline ::suil::tmsp::types::Timestamp* Header::release_time() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.Header.time)
  
  ::suil::tmsp::types::Timestamp* temp = time_;
  time_ = nullptr;
  return temp;
}
inline ::suil::tmsp::types::Timestamp* Header::mutable_time() {
  
  if (time_ == nullptr) {
    auto* p = CreateMaybeMessage<::suil::tmsp::types::Timestamp>(GetArenaNoVirtual());
    time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.Header.time)
  return time_;
}
inline void Header::set_allocated_time(::suil::tmsp::types::Timestamp* time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete time_;
  }
  if (time) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    
  } else {
    
  }
  time_ = time;
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.Header.time)
}

// int64 num_txs = 5;
inline void Header::clear_num_txs() {
  num_txs_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 Header::num_txs() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Header.num_txs)
  return num_txs_;
}
inline void Header::set_num_txs(::google::protobuf::int64 value) {
  
  num_txs_ = value;
  // @@protoc_insertion_point(field_set:suil.tmsp.types.Header.num_txs)
}

// int64 total_txs = 6;
inline void Header::clear_total_txs() {
  total_txs_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 Header::total_txs() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Header.total_txs)
  return total_txs_;
}
inline void Header::set_total_txs(::google::protobuf::int64 value) {
  
  total_txs_ = value;
  // @@protoc_insertion_point(field_set:suil.tmsp.types.Header.total_txs)
}

// .suil.tmsp.types.BlockID last_block_id = 7;
inline bool Header::has_last_block_id() const {
  return this != internal_default_instance() && last_block_id_ != nullptr;
}
inline void Header::clear_last_block_id() {
  if (GetArenaNoVirtual() == nullptr && last_block_id_ != nullptr) {
    delete last_block_id_;
  }
  last_block_id_ = nullptr;
}
inline const ::suil::tmsp::types::BlockID& Header::last_block_id() const {
  const ::suil::tmsp::types::BlockID* p = last_block_id_;
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Header.last_block_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::suil::tmsp::types::BlockID*>(
      &::suil::tmsp::types::_BlockID_default_instance_);
}
inline ::suil::tmsp::types::BlockID* Header::release_last_block_id() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.Header.last_block_id)
  
  ::suil::tmsp::types::BlockID* temp = last_block_id_;
  last_block_id_ = nullptr;
  return temp;
}
inline ::suil::tmsp::types::BlockID* Header::mutable_last_block_id() {
  
  if (last_block_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::suil::tmsp::types::BlockID>(GetArenaNoVirtual());
    last_block_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.Header.last_block_id)
  return last_block_id_;
}
inline void Header::set_allocated_last_block_id(::suil::tmsp::types::BlockID* last_block_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete last_block_id_;
  }
  if (last_block_id) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      last_block_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, last_block_id, submessage_arena);
    }
    
  } else {
    
  }
  last_block_id_ = last_block_id;
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.Header.last_block_id)
}

// bytes last_commit_hash = 8;
inline void Header::clear_last_commit_hash() {
  last_commit_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Header::last_commit_hash() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Header.last_commit_hash)
  return last_commit_hash_.GetNoArena();
}
inline void Header::set_last_commit_hash(const ::std::string& value) {
  
  last_commit_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.Header.last_commit_hash)
}
#if LANG_CXX11
inline void Header::set_last_commit_hash(::std::string&& value) {
  
  last_commit_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.Header.last_commit_hash)
}
#endif
inline void Header::set_last_commit_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  last_commit_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.Header.last_commit_hash)
}
inline void Header::set_last_commit_hash(const void* value, size_t size) {
  
  last_commit_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.Header.last_commit_hash)
}
inline ::std::string* Header::mutable_last_commit_hash() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.Header.last_commit_hash)
  return last_commit_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_last_commit_hash() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.Header.last_commit_hash)
  
  return last_commit_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_last_commit_hash(::std::string* last_commit_hash) {
  if (last_commit_hash != nullptr) {
    
  } else {
    
  }
  last_commit_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), last_commit_hash);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.Header.last_commit_hash)
}

// bytes data_hash = 9;
inline void Header::clear_data_hash() {
  data_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Header::data_hash() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Header.data_hash)
  return data_hash_.GetNoArena();
}
inline void Header::set_data_hash(const ::std::string& value) {
  
  data_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.Header.data_hash)
}
#if LANG_CXX11
inline void Header::set_data_hash(::std::string&& value) {
  
  data_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.Header.data_hash)
}
#endif
inline void Header::set_data_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  data_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.Header.data_hash)
}
inline void Header::set_data_hash(const void* value, size_t size) {
  
  data_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.Header.data_hash)
}
inline ::std::string* Header::mutable_data_hash() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.Header.data_hash)
  return data_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_data_hash() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.Header.data_hash)
  
  return data_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_data_hash(::std::string* data_hash) {
  if (data_hash != nullptr) {
    
  } else {
    
  }
  data_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data_hash);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.Header.data_hash)
}

// bytes validators_hash = 10;
inline void Header::clear_validators_hash() {
  validators_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Header::validators_hash() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Header.validators_hash)
  return validators_hash_.GetNoArena();
}
inline void Header::set_validators_hash(const ::std::string& value) {
  
  validators_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.Header.validators_hash)
}
#if LANG_CXX11
inline void Header::set_validators_hash(::std::string&& value) {
  
  validators_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.Header.validators_hash)
}
#endif
inline void Header::set_validators_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  validators_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.Header.validators_hash)
}
inline void Header::set_validators_hash(const void* value, size_t size) {
  
  validators_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.Header.validators_hash)
}
inline ::std::string* Header::mutable_validators_hash() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.Header.validators_hash)
  return validators_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_validators_hash() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.Header.validators_hash)
  
  return validators_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_validators_hash(::std::string* validators_hash) {
  if (validators_hash != nullptr) {
    
  } else {
    
  }
  validators_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), validators_hash);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.Header.validators_hash)
}

// bytes next_validators_hash = 11;
inline void Header::clear_next_validators_hash() {
  next_validators_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Header::next_validators_hash() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Header.next_validators_hash)
  return next_validators_hash_.GetNoArena();
}
inline void Header::set_next_validators_hash(const ::std::string& value) {
  
  next_validators_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.Header.next_validators_hash)
}
#if LANG_CXX11
inline void Header::set_next_validators_hash(::std::string&& value) {
  
  next_validators_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.Header.next_validators_hash)
}
#endif
inline void Header::set_next_validators_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  next_validators_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.Header.next_validators_hash)
}
inline void Header::set_next_validators_hash(const void* value, size_t size) {
  
  next_validators_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.Header.next_validators_hash)
}
inline ::std::string* Header::mutable_next_validators_hash() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.Header.next_validators_hash)
  return next_validators_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_next_validators_hash() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.Header.next_validators_hash)
  
  return next_validators_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_next_validators_hash(::std::string* next_validators_hash) {
  if (next_validators_hash != nullptr) {
    
  } else {
    
  }
  next_validators_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), next_validators_hash);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.Header.next_validators_hash)
}

// bytes consensus_hash = 12;
inline void Header::clear_consensus_hash() {
  consensus_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Header::consensus_hash() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Header.consensus_hash)
  return consensus_hash_.GetNoArena();
}
inline void Header::set_consensus_hash(const ::std::string& value) {
  
  consensus_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.Header.consensus_hash)
}
#if LANG_CXX11
inline void Header::set_consensus_hash(::std::string&& value) {
  
  consensus_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.Header.consensus_hash)
}
#endif
inline void Header::set_consensus_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  consensus_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.Header.consensus_hash)
}
inline void Header::set_consensus_hash(const void* value, size_t size) {
  
  consensus_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.Header.consensus_hash)
}
inline ::std::string* Header::mutable_consensus_hash() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.Header.consensus_hash)
  return consensus_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_consensus_hash() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.Header.consensus_hash)
  
  return consensus_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_consensus_hash(::std::string* consensus_hash) {
  if (consensus_hash != nullptr) {
    
  } else {
    
  }
  consensus_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), consensus_hash);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.Header.consensus_hash)
}

// bytes app_hash = 13;
inline void Header::clear_app_hash() {
  app_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Header::app_hash() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Header.app_hash)
  return app_hash_.GetNoArena();
}
inline void Header::set_app_hash(const ::std::string& value) {
  
  app_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.Header.app_hash)
}
#if LANG_CXX11
inline void Header::set_app_hash(::std::string&& value) {
  
  app_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.Header.app_hash)
}
#endif
inline void Header::set_app_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  app_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.Header.app_hash)
}
inline void Header::set_app_hash(const void* value, size_t size) {
  
  app_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.Header.app_hash)
}
inline ::std::string* Header::mutable_app_hash() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.Header.app_hash)
  return app_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_app_hash() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.Header.app_hash)
  
  return app_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_app_hash(::std::string* app_hash) {
  if (app_hash != nullptr) {
    
  } else {
    
  }
  app_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), app_hash);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.Header.app_hash)
}

// bytes last_results_hash = 14;
inline void Header::clear_last_results_hash() {
  last_results_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Header::last_results_hash() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Header.last_results_hash)
  return last_results_hash_.GetNoArena();
}
inline void Header::set_last_results_hash(const ::std::string& value) {
  
  last_results_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.Header.last_results_hash)
}
#if LANG_CXX11
inline void Header::set_last_results_hash(::std::string&& value) {
  
  last_results_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.Header.last_results_hash)
}
#endif
inline void Header::set_last_results_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  last_results_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.Header.last_results_hash)
}
inline void Header::set_last_results_hash(const void* value, size_t size) {
  
  last_results_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.Header.last_results_hash)
}
inline ::std::string* Header::mutable_last_results_hash() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.Header.last_results_hash)
  return last_results_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_last_results_hash() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.Header.last_results_hash)
  
  return last_results_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_last_results_hash(::std::string* last_results_hash) {
  if (last_results_hash != nullptr) {
    
  } else {
    
  }
  last_results_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), last_results_hash);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.Header.last_results_hash)
}

// bytes evidence_hash = 15;
inline void Header::clear_evidence_hash() {
  evidence_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Header::evidence_hash() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Header.evidence_hash)
  return evidence_hash_.GetNoArena();
}
inline void Header::set_evidence_hash(const ::std::string& value) {
  
  evidence_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.Header.evidence_hash)
}
#if LANG_CXX11
inline void Header::set_evidence_hash(::std::string&& value) {
  
  evidence_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.Header.evidence_hash)
}
#endif
inline void Header::set_evidence_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  evidence_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.Header.evidence_hash)
}
inline void Header::set_evidence_hash(const void* value, size_t size) {
  
  evidence_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.Header.evidence_hash)
}
inline ::std::string* Header::mutable_evidence_hash() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.Header.evidence_hash)
  return evidence_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_evidence_hash() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.Header.evidence_hash)
  
  return evidence_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_evidence_hash(::std::string* evidence_hash) {
  if (evidence_hash != nullptr) {
    
  } else {
    
  }
  evidence_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), evidence_hash);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.Header.evidence_hash)
}

// bytes proposer_address = 16;
inline void Header::clear_proposer_address() {
  proposer_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Header::proposer_address() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Header.proposer_address)
  return proposer_address_.GetNoArena();
}
inline void Header::set_proposer_address(const ::std::string& value) {
  
  proposer_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.Header.proposer_address)
}
#if LANG_CXX11
inline void Header::set_proposer_address(::std::string&& value) {
  
  proposer_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.Header.proposer_address)
}
#endif
inline void Header::set_proposer_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  proposer_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.Header.proposer_address)
}
inline void Header::set_proposer_address(const void* value, size_t size) {
  
  proposer_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.Header.proposer_address)
}
inline ::std::string* Header::mutable_proposer_address() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.Header.proposer_address)
  return proposer_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_proposer_address() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.Header.proposer_address)
  
  return proposer_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_proposer_address(::std::string* proposer_address) {
  if (proposer_address != nullptr) {
    
  } else {
    
  }
  proposer_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), proposer_address);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.Header.proposer_address)
}

// -------------------------------------------------------------------

// Version

// uint64 Block = 1;
inline void Version::clear_block() {
  block_ = PROTOBUF_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Version::block() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Version.Block)
  return block_;
}
inline void Version::set_block(::google::protobuf::uint64 value) {
  
  block_ = value;
  // @@protoc_insertion_point(field_set:suil.tmsp.types.Version.Block)
}

// uint64 App = 2;
inline void Version::clear_app() {
  app_ = PROTOBUF_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Version::app() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Version.App)
  return app_;
}
inline void Version::set_app(::google::protobuf::uint64 value) {
  
  app_ = value;
  // @@protoc_insertion_point(field_set:suil.tmsp.types.Version.App)
}

// -------------------------------------------------------------------

// BlockID

// bytes hash = 1;
inline void BlockID::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BlockID::hash() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.BlockID.hash)
  return hash_.GetNoArena();
}
inline void BlockID::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.BlockID.hash)
}
#if LANG_CXX11
inline void BlockID::set_hash(::std::string&& value) {
  
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.BlockID.hash)
}
#endif
inline void BlockID::set_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.BlockID.hash)
}
inline void BlockID::set_hash(const void* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.BlockID.hash)
}
inline ::std::string* BlockID::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.BlockID.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlockID::release_hash() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.BlockID.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlockID::set_allocated_hash(::std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.BlockID.hash)
}

// .suil.tmsp.types.PartSetHeader parts_header = 2;
inline bool BlockID::has_parts_header() const {
  return this != internal_default_instance() && parts_header_ != nullptr;
}
inline void BlockID::clear_parts_header() {
  if (GetArenaNoVirtual() == nullptr && parts_header_ != nullptr) {
    delete parts_header_;
  }
  parts_header_ = nullptr;
}
inline const ::suil::tmsp::types::PartSetHeader& BlockID::parts_header() const {
  const ::suil::tmsp::types::PartSetHeader* p = parts_header_;
  // @@protoc_insertion_point(field_get:suil.tmsp.types.BlockID.parts_header)
  return p != nullptr ? *p : *reinterpret_cast<const ::suil::tmsp::types::PartSetHeader*>(
      &::suil::tmsp::types::_PartSetHeader_default_instance_);
}
inline ::suil::tmsp::types::PartSetHeader* BlockID::release_parts_header() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.BlockID.parts_header)
  
  ::suil::tmsp::types::PartSetHeader* temp = parts_header_;
  parts_header_ = nullptr;
  return temp;
}
inline ::suil::tmsp::types::PartSetHeader* BlockID::mutable_parts_header() {
  
  if (parts_header_ == nullptr) {
    auto* p = CreateMaybeMessage<::suil::tmsp::types::PartSetHeader>(GetArenaNoVirtual());
    parts_header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.BlockID.parts_header)
  return parts_header_;
}
inline void BlockID::set_allocated_parts_header(::suil::tmsp::types::PartSetHeader* parts_header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete parts_header_;
  }
  if (parts_header) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      parts_header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, parts_header, submessage_arena);
    }
    
  } else {
    
  }
  parts_header_ = parts_header;
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.BlockID.parts_header)
}

// -------------------------------------------------------------------

// PartSetHeader

// int32 total = 1;
inline void PartSetHeader::clear_total() {
  total_ = 0;
}
inline ::google::protobuf::int32 PartSetHeader::total() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.PartSetHeader.total)
  return total_;
}
inline void PartSetHeader::set_total(::google::protobuf::int32 value) {
  
  total_ = value;
  // @@protoc_insertion_point(field_set:suil.tmsp.types.PartSetHeader.total)
}

// bytes hash = 2;
inline void PartSetHeader::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PartSetHeader::hash() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.PartSetHeader.hash)
  return hash_.GetNoArena();
}
inline void PartSetHeader::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.PartSetHeader.hash)
}
#if LANG_CXX11
inline void PartSetHeader::set_hash(::std::string&& value) {
  
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.PartSetHeader.hash)
}
#endif
inline void PartSetHeader::set_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.PartSetHeader.hash)
}
inline void PartSetHeader::set_hash(const void* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.PartSetHeader.hash)
}
inline ::std::string* PartSetHeader::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.PartSetHeader.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PartSetHeader::release_hash() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.PartSetHeader.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PartSetHeader::set_allocated_hash(::std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.PartSetHeader.hash)
}

// -------------------------------------------------------------------

// Validator

// bytes address = 1;
inline void Validator::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Validator::address() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Validator.address)
  return address_.GetNoArena();
}
inline void Validator::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.Validator.address)
}
#if LANG_CXX11
inline void Validator::set_address(::std::string&& value) {
  
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.Validator.address)
}
#endif
inline void Validator::set_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.Validator.address)
}
inline void Validator::set_address(const void* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.Validator.address)
}
inline ::std::string* Validator::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.Validator.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Validator::release_address() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.Validator.address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Validator::set_allocated_address(::std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.Validator.address)
}

// int64 power = 3;
inline void Validator::clear_power() {
  power_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 Validator::power() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Validator.power)
  return power_;
}
inline void Validator::set_power(::google::protobuf::int64 value) {
  
  power_ = value;
  // @@protoc_insertion_point(field_set:suil.tmsp.types.Validator.power)
}

// -------------------------------------------------------------------

// ValidatorUpdate

// .suil.tmsp.types.PubKey pub_key = 1;
inline bool ValidatorUpdate::has_pub_key() const {
  return this != internal_default_instance() && pub_key_ != nullptr;
}
inline void ValidatorUpdate::clear_pub_key() {
  if (GetArenaNoVirtual() == nullptr && pub_key_ != nullptr) {
    delete pub_key_;
  }
  pub_key_ = nullptr;
}
inline const ::suil::tmsp::types::PubKey& ValidatorUpdate::pub_key() const {
  const ::suil::tmsp::types::PubKey* p = pub_key_;
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ValidatorUpdate.pub_key)
  return p != nullptr ? *p : *reinterpret_cast<const ::suil::tmsp::types::PubKey*>(
      &::suil::tmsp::types::_PubKey_default_instance_);
}
inline ::suil::tmsp::types::PubKey* ValidatorUpdate::release_pub_key() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.ValidatorUpdate.pub_key)
  
  ::suil::tmsp::types::PubKey* temp = pub_key_;
  pub_key_ = nullptr;
  return temp;
}
inline ::suil::tmsp::types::PubKey* ValidatorUpdate::mutable_pub_key() {
  
  if (pub_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::suil::tmsp::types::PubKey>(GetArenaNoVirtual());
    pub_key_ = p;
  }
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.ValidatorUpdate.pub_key)
  return pub_key_;
}
inline void ValidatorUpdate::set_allocated_pub_key(::suil::tmsp::types::PubKey* pub_key) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete pub_key_;
  }
  if (pub_key) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      pub_key = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pub_key, submessage_arena);
    }
    
  } else {
    
  }
  pub_key_ = pub_key;
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.ValidatorUpdate.pub_key)
}

// int64 power = 2;
inline void ValidatorUpdate::clear_power() {
  power_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 ValidatorUpdate::power() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.ValidatorUpdate.power)
  return power_;
}
inline void ValidatorUpdate::set_power(::google::protobuf::int64 value) {
  
  power_ = value;
  // @@protoc_insertion_point(field_set:suil.tmsp.types.ValidatorUpdate.power)
}

// -------------------------------------------------------------------

// VoteInfo

// .suil.tmsp.types.Validator validator = 1;
inline bool VoteInfo::has_validator() const {
  return this != internal_default_instance() && validator_ != nullptr;
}
inline void VoteInfo::clear_validator() {
  if (GetArenaNoVirtual() == nullptr && validator_ != nullptr) {
    delete validator_;
  }
  validator_ = nullptr;
}
inline const ::suil::tmsp::types::Validator& VoteInfo::validator() const {
  const ::suil::tmsp::types::Validator* p = validator_;
  // @@protoc_insertion_point(field_get:suil.tmsp.types.VoteInfo.validator)
  return p != nullptr ? *p : *reinterpret_cast<const ::suil::tmsp::types::Validator*>(
      &::suil::tmsp::types::_Validator_default_instance_);
}
inline ::suil::tmsp::types::Validator* VoteInfo::release_validator() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.VoteInfo.validator)
  
  ::suil::tmsp::types::Validator* temp = validator_;
  validator_ = nullptr;
  return temp;
}
inline ::suil::tmsp::types::Validator* VoteInfo::mutable_validator() {
  
  if (validator_ == nullptr) {
    auto* p = CreateMaybeMessage<::suil::tmsp::types::Validator>(GetArenaNoVirtual());
    validator_ = p;
  }
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.VoteInfo.validator)
  return validator_;
}
inline void VoteInfo::set_allocated_validator(::suil::tmsp::types::Validator* validator) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete validator_;
  }
  if (validator) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      validator = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, validator, submessage_arena);
    }
    
  } else {
    
  }
  validator_ = validator;
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.VoteInfo.validator)
}

// bool signed_last_block = 2;
inline void VoteInfo::clear_signed_last_block() {
  signed_last_block_ = false;
}
inline bool VoteInfo::signed_last_block() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.VoteInfo.signed_last_block)
  return signed_last_block_;
}
inline void VoteInfo::set_signed_last_block(bool value) {
  
  signed_last_block_ = value;
  // @@protoc_insertion_point(field_set:suil.tmsp.types.VoteInfo.signed_last_block)
}

// -------------------------------------------------------------------

// PubKey

// string type = 1;
inline void PubKey::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PubKey::type() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.PubKey.type)
  return type_.GetNoArena();
}
inline void PubKey::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.PubKey.type)
}
#if LANG_CXX11
inline void PubKey::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.PubKey.type)
}
#endif
inline void PubKey::set_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.PubKey.type)
}
inline void PubKey::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.PubKey.type)
}
inline ::std::string* PubKey::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.PubKey.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PubKey::release_type() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.PubKey.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PubKey::set_allocated_type(::std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.PubKey.type)
}

// bytes data = 2;
inline void PubKey::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PubKey::data() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.PubKey.data)
  return data_.GetNoArena();
}
inline void PubKey::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.PubKey.data)
}
#if LANG_CXX11
inline void PubKey::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.PubKey.data)
}
#endif
inline void PubKey::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.PubKey.data)
}
inline void PubKey::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.PubKey.data)
}
inline ::std::string* PubKey::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.PubKey.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PubKey::release_data() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.PubKey.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PubKey::set_allocated_data(::std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.PubKey.data)
}

// -------------------------------------------------------------------

// Evidence

// string type = 1;
inline void Evidence::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Evidence::type() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Evidence.type)
  return type_.GetNoArena();
}
inline void Evidence::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:suil.tmsp.types.Evidence.type)
}
#if LANG_CXX11
inline void Evidence::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:suil.tmsp.types.Evidence.type)
}
#endif
inline void Evidence::set_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:suil.tmsp.types.Evidence.type)
}
inline void Evidence::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:suil.tmsp.types.Evidence.type)
}
inline ::std::string* Evidence::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.Evidence.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Evidence::release_type() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.Evidence.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Evidence::set_allocated_type(::std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.Evidence.type)
}

// .suil.tmsp.types.Validator validator = 2;
inline bool Evidence::has_validator() const {
  return this != internal_default_instance() && validator_ != nullptr;
}
inline void Evidence::clear_validator() {
  if (GetArenaNoVirtual() == nullptr && validator_ != nullptr) {
    delete validator_;
  }
  validator_ = nullptr;
}
inline const ::suil::tmsp::types::Validator& Evidence::validator() const {
  const ::suil::tmsp::types::Validator* p = validator_;
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Evidence.validator)
  return p != nullptr ? *p : *reinterpret_cast<const ::suil::tmsp::types::Validator*>(
      &::suil::tmsp::types::_Validator_default_instance_);
}
inline ::suil::tmsp::types::Validator* Evidence::release_validator() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.Evidence.validator)
  
  ::suil::tmsp::types::Validator* temp = validator_;
  validator_ = nullptr;
  return temp;
}
inline ::suil::tmsp::types::Validator* Evidence::mutable_validator() {
  
  if (validator_ == nullptr) {
    auto* p = CreateMaybeMessage<::suil::tmsp::types::Validator>(GetArenaNoVirtual());
    validator_ = p;
  }
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.Evidence.validator)
  return validator_;
}
inline void Evidence::set_allocated_validator(::suil::tmsp::types::Validator* validator) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete validator_;
  }
  if (validator) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      validator = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, validator, submessage_arena);
    }
    
  } else {
    
  }
  validator_ = validator;
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.Evidence.validator)
}

// int64 height = 3;
inline void Evidence::clear_height() {
  height_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 Evidence::height() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Evidence.height)
  return height_;
}
inline void Evidence::set_height(::google::protobuf::int64 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:suil.tmsp.types.Evidence.height)
}

// .suil.tmsp.types.Timestamp time = 4;
inline bool Evidence::has_time() const {
  return this != internal_default_instance() && time_ != nullptr;
}
inline void Evidence::clear_time() {
  if (GetArenaNoVirtual() == nullptr && time_ != nullptr) {
    delete time_;
  }
  time_ = nullptr;
}
inline const ::suil::tmsp::types::Timestamp& Evidence::time() const {
  const ::suil::tmsp::types::Timestamp* p = time_;
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Evidence.time)
  return p != nullptr ? *p : *reinterpret_cast<const ::suil::tmsp::types::Timestamp*>(
      &::suil::tmsp::types::_Timestamp_default_instance_);
}
inline ::suil::tmsp::types::Timestamp* Evidence::release_time() {
  // @@protoc_insertion_point(field_release:suil.tmsp.types.Evidence.time)
  
  ::suil::tmsp::types::Timestamp* temp = time_;
  time_ = nullptr;
  return temp;
}
inline ::suil::tmsp::types::Timestamp* Evidence::mutable_time() {
  
  if (time_ == nullptr) {
    auto* p = CreateMaybeMessage<::suil::tmsp::types::Timestamp>(GetArenaNoVirtual());
    time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:suil.tmsp.types.Evidence.time)
  return time_;
}
inline void Evidence::set_allocated_time(::suil::tmsp::types::Timestamp* time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete time_;
  }
  if (time) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    
  } else {
    
  }
  time_ = time;
  // @@protoc_insertion_point(field_set_allocated:suil.tmsp.types.Evidence.time)
}

// int64 total_voting_power = 5;
inline void Evidence::clear_total_voting_power() {
  total_voting_power_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 Evidence::total_voting_power() const {
  // @@protoc_insertion_point(field_get:suil.tmsp.types.Evidence.total_voting_power)
  return total_voting_power_;
}
inline void Evidence::set_total_voting_power(::google::protobuf::int64 value) {
  
  total_voting_power_ = value;
  // @@protoc_insertion_point(field_set:suil.tmsp.types.Evidence.total_voting_power)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace types
}  // namespace tmsp
}  // namespace suil

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_types_2eproto
